[{"name": "app.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Apr  2 15:45:31\n\n@author: JM-RPC\n\"\"\"\n#import pdb; pdb.set_trace()\nfrom sklearn.metrics import roc_curve, auc\nimport statsmodels.api  as sm\nimport statsmodels.formula.api as smf\nfrom statsmodels.graphics.regressionplots import plot_partregress_grid, plot_leverage_resid2, influence_plot, plot_fit\nfrom scipy import stats\nimport numpy as np\nimport pandas as pd\nimport io\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport seaborn as sb\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\nimport shinywidgets\nfrom shinywidgets import render_widget, output_widget\nimport plotly.graph_objs as go\nimport os\nimport signal\nfrom datetime import datetime\nfrom shinywidgets import output_widget, render_widget\n\nmax_factor_values = 25\n\nbasecolors0 = ['red',  'blue', 'green', 'goldenrod', 'violet','cyan', 'yellow','grey','gold','magenta','silver','orange','olive','khaki','thistle']\nbasecolorsalpha = ['red',  'blue', 'green', 'goldenrod', 'violet','cyan', 'yellow','grey','gold','magenta']\nbasecolors = [matplotlib.colors.to_rgba(item,alpha = None) for item in basecolorsalpha]\nprotected_names = ['Residuals','Predictions','Deviance_Resid','CI_lb', 'CI_ub','PI_lb', 'PI_ub']\n\ndef getcolor(col_data):\n    dfc = pd.DataFrame(col_data).astype('str')\n    choicesCo = list(dfc[dfc.columns[0]].astype('str').unique())\n    choicesCo.sort()\n    if (len(choicesCo) < len(basecolors)):\n        colorD = {item : basecolors[choicesCo.index(item)]  for item in choicesCo}\n        colorlist = [colorD[item] for item in col_data]\n        lpatches = [mpatches.Patch(color = colorD[item],label = item) for item in colorD.keys()]\n    else:\n        cmap = plt.cm.plasma\n        #colorNos = [choicesCo.index(item) for item in col_data]\n        colorD = {item : cmap(choicesCo.index(item)/len(choicesCo)) for item in choicesCo}\n        colorlist = [colorD[item] for item in col_data]\n        lpatches = [mpatches.Patch(color = colorD[item],label = item) for item in choicesCo]\n    return colorlist, lpatches, colorD\n\ndef collisionAvoidance(name,namelist):\n    while name in namelist: \n        name = name + '_0'        \n    return(name)\n\ndef doCorr(xv, yv, **kws):\n    r,p = stats.pearsonr(xv,yv)\n    ax = plt.gca()\n    ax.annotate(\"r = {:.3f}, p = {:.3f}\".format(r,p),xy=(.1, .9), xycoords=ax.transAxes)\n\napp_ui = ui.page_navbar( \n    ui.nav_panel(\"Plotting\",\n                 ui.row(\n                     ui.column(4,offset = 0,*[ui.input_file(\"file1\", \"Choose .csv or .dta File\", accept=[\".csv\",\".CSV\",\".dta\",\".DTA\"], multiple=False, placeholder = '', width = \"600px\")]),\n                     ui.column(4,offset = 0,*[ui.input_radio_buttons('killna', 'On input remove rows with missing data in one or more columns?',choices = ['No','Yes'],inline = True)]),\n                     ui.column(4,offset = 0,),\n                     ),\n                 ui.row(\n                     ui.output_text(\"plt_mess\",inline = True)\n                     ),\n                 ui.row(\n                     ui.input_radio_buttons(\"datachoose\",\"Data:\",choices = ['Input Data'], selected = 'Input Data', inline = True),\n                     ),\n                 ui.row(\n                     ui.column(2,offset=0,*[ ui.input_selectize(\"xvar\",\"X variable:\",choices = ['-'], multiple=False)]),\n                     ui.column(2,offset=0,*[ ui.input_selectize(\"yvar\",\"Y variable:\",choices = ['-'], multiple=False)]),\n                     ui.column(2,offset=0,*[ ui.input_selectize(\"zvar\",\"Z variable:\",choices = ['-'], multiple=False)]),\n                     ui.column(2,offset=0,*[ ui.input_selectize(\"cvar\",\"Color with:\",choices = ['-'], multiple=False)]),\n                     ),\n                 ui.row(\n                     ui.column(1,offset=0,*[ui.input_action_button(\"updateB\", \"Update\")]),\n                     ui.column(1,offset=0),\n                     ui.output_ui(\"pltopts\"),\n                     ui.column(1,offset=0),\n                     ui.column(3,offset = 0,*[ui.download_button(\"downloadDP\",\"Save Plotting Data\",width = \"200px\")]),                \n                     ),\n                 ui.row(ui.output_ui(\"grphopts\"),\n                     ),\n                 ui.row(\n                     ui.input_selectize(\"fvar\",\"Filter On:\" ,choices = ['-'], multiple=False),\n                     ui.input_selectize(\"fitems\",\"Included Rows:\",choices = ['-'], multiple=True),\n                     ),\n                 ui.row(\n                        ui.HTML(\"<p>Rows Selected (filter on \\\"-\\\" above to clear filter).</p>\"),\n                     ),\n                 ui.row(\n                     ui.output_text_verbatim(\"log\")\n                     ),\n                 ui.row(\n                        ui.input_text(\"titleplt\",\"Plot Title:\", value = '-', width = '800px', )\n                     ),\n                 ui.row(ui.HTML(\"<p>These bounds override plot bounds.  To reset reselect the variable.</p>\")\n                     ),\n                 ui.row(\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"xlb\", \"X lower bound:\", value=\"\",width=10)]),\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"xub\", \"X upper bound:\", value=\"\",width=10)]),\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"ylb\", \"Y lower bound:\", value=\"\",width=10)]),\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"yub\", \"Y upper bound:\", value=\"\",width=10)]),\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"zlb\", \"Z lower bound:\", value=\"\",width=10)]),\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"zub\", \"Z upper bound:\", value=\"\",width=10)]),\n                     ),\n                 ),\n    ui.nav_panel(\"Plot Extras\",\n                   ui.row(ui.HTML(\"<p> Additional data series:</p>\"),\n                      ),\n                   ui.row(\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w1var\",\"W1 variable:\",choices = ['-'], multiple=False)]),\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w2var\",\"W2 variable:\",choices = ['-'], multiple=False)]),\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w3var\",\"W3 variable:\",choices = ['-'], multiple=False)]),\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w4var\",\"W4 variable:\",choices = ['-'], multiple=False)]),\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w5var\",\"W5 variable:\",choices = ['-'], multiple=False)]),\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w6var\",\"W6 variable:\",choices = ['-'], multiple=False)]),\n                       ),\n                    ui.row(\n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"w1mark\",\"Type:\",choices = ['dot','line'],inline = True)]),                    \n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"w2mark\",\"Type:\",choices = ['dot','line'],inline = True)]),\n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"w3mark\",\"Type:\",choices = ['dot','line'],inline = True)]),\n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"w4mark\",\"Type:\",choices = ['dot','line'],inline = True)]),\n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"w5mark\",\"Type:\",choices = ['dot','line'],inline = True)]),\n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"w6mark\",\"Type:\",choices = ['dot','line'],inline = True)]),\n                        ),\n                   ui.row(\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w1col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w2col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w3col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w4col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w5col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ui.column(2,offset=0,*[ ui.input_selectize(\"w6col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ),\n                   ui.row(\n                       ui.column(2,offset=0,*[ ui.input_numeric(\"siglev\", \"Significance Level:\", value=\"0.05\",width=20)]),\n                       ),\n                   ),\n    \n    ui.nav_panel(\"Data View\",\n                 #ui.input_file(\"file1\", \"Choose .csv or .dta File\", accept=[\".csv\",\".CSV\",\".dta\",\".DTA\"], multiple=False, width = \"500px\", placeholder = ''),\n                 #ui.output_text('io_mess'),ui.input_radio_buttons('killna', 'Remove rows with missing data in one or more columns?',choices = ['No','Yes']),\n                 ui.row(ui.output_data_frame(\"info\"), height = '300px'),\n                 ui.row(ui.HTML(\"<p> </p>\")),\n                 ui.row(ui.output_data_frame(\"summary\")),\n                 ui.row(ui.HTML(\"<p> </p>\")),\n                 ui.row(ui.output_data_frame(\"data\")),\n                 ),\n\n    ui.nav_panel(\"Correlations\",\n                   ui.row(ui.input_selectize(\"corrV\",\"Select variables:\",choices = [''],multiple = True,width = \"200px\")),\n                   ui.output_plot(\"dataPD\",width = '1200px', height = '1200px'),\n                 ),\n    ui.nav_panel(\"Linear Models\",\n                 ui.row(\n                     ui.column(6,offset=0,*[ui.input_radio_buttons(\"mtype\",\"Model Type\",choices = ['OLS','LOGIT','POISSON','NEGATIVE_BINOMIAL'],inline = True)]),\n                     ui.column(3,offset = 0,*[ui.output_ui(\"nbparm\")]),\n                     ui.column(3,offset = 0),\n                     ),\n                 ui.row(\n                     ui.column(3, offset = 0, *[ui.input_selectize(\"depvar\",\"Dependent Variable:\",choices = ['-'],multiple = False)]),\n                     ui.column(5, offset = 0, *[ui.input_selectize(\"indvar\",\"Independent Variables:\", choices = ['-'],multiple = True, width = \"600px\")]),\n                     ui.column(4, offset = 0, *[ui.input_selectize(\"tofactor\",\"Convert Numeric Variables to factors:\", choices = ['-'],multiple = True)]),\n                     ),\n                 ui.row(ui.HTML(\"<p> Use Wilkinson/Patsy notation to specify variable transformations.</p>\")\n                     ),\n                 ui.row(\n                     ui.column(2, offset = 0, *[ui.input_action_button('modelGo',\"Run Model\")]),\n                     ui.column(10, offset = 0, *[ui.input_text('stringM','Model String:',width = '1000px')]),\n                     #ui.column(2, offset = 0, *[ui.input_action_button('modelClear',\"Clear Model\")]),\n                     ),\n                 ui.row(\n                     ui.output_ui(\"dloads\"),\n                     ),\n                 ui.row(\n                     ui.output_text_verbatim(\"modelSummary\")\n                     ),\n                 ),\n    ui.nav_panel(\"Linear Models: Standard Plots\",\n                  ui.row(\n                      ui.column(6,offset=0,*[ui.input_radio_buttons(\"regplotR\",\"Plot: \",choices = ['ROC', 'Leverage','Partial Regression','Influence','Fit'],inline = True)]),\n                      ui.column(6,offset=0,*[ui.input_select(\"lmsp\",\"Fit: Ind. Var:\",choices = ['-'])]),\n                      ),\n                  ui.row(\n                      ui.output_plot(\"regplot1\", width = \"900px\", height = \"600px\")\n                      ),\n                  # ui.row(\n                  #     ui.output_plot(\"regplot3\", width = \"900px\", height = \"600px\")\n                  #     ),\n                  ),\n    ui.nav_panel(\"Log\",\n                  ui.input_action_button(\"logGo\",\"Update Log\"),\n                  ui.download_button(\"logdown\",\"Download Log\"),\n                  ui.input_action_button(\"resetlog\", \"Reset Log\"),\n                  ui.output_text_verbatim(\"logout\")\n                  ),\n    ui.nav_spacer(),\n    ui.nav_menu(\"Exit\",\n                 ui.nav_control(\n                     ui.column(1,offset=0,*[ui.input_action_button(\"exit\",\"Exit\")]),\n                     ),\n                 ),\n    \n               \nunderline = True, title = \"plotit v.0.0.3 \")\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    mdl_type = reactive.value(\"OLS\") #currently supported types: OLS, LOGIT\n    mdl = reactive.value(None)\n    mdl_depvar = reactive.value('-')\n    mdl_indvar = reactive.value(())\n    mdl_stringM = reactive.value(\" - ~ \")\n    mdl_data = reactive.value(pd.DataFrame())\n    subdict = reactive.value({})\n    logstr = reactive.value(\"\")\n    dbgstr = reactive.value(f\"At server start: Figures: {plt.get_fignums()} \\n\")\n    plt_msgstr = reactive.value(\"\")\n    io_msgstr = reactive.value(\"\")\n    lm_msgstr = reactive.value(\"\")\n    plt_data = reactive.value(pd.DataFrame())\n    logstr = reactive.value(f\"Log Start: {datetime.now()}\")\n    trendOn = reactive.value(False)\n\n    @reactive.effect\n    @reactive.event(input.exit)\n    async def do_exit():\n        #plt.close(fig)\n        await session.app.stop()\n        os.kill(os.getpid(), signal.SIGTERM)\n        max_factor_values = 50\n\n        \n##########################################################################\n####  Log panel\n##########################################################################\n    @render.text  \n    @reactive.event(input.logGo)\n    def logout():\n        return logstr()\n    \n    @reactive.effect\n    @reactive.event(input.resetlog)\n    def resetL():\n        logstr.set(f\"Log Start: {datetime.now()}\")\n        return\n    \n    def pushlog2(newlogstr):\n        # with reactive.isolate():\n        #     logstr.set(logstr() + '\\n ****'  + newlogstr)\n        return    \n    \n    def pushlog(newlogstr):\n        with reactive.isolate():\n            logstr.set(logstr() + '\\n'+ newlogstr)\n        return\n\n    @render.download(filename = \"Logfile.txt\")\n    def logdown():\n        loglst = logstr().splitlines()\n        dflog = pd.DataFrame(loglst)\n        yield dflog.to_csv(index = False)\n\n        \n##########################################################################\n####  Input panel\n##########################################################################\n\n    @reactive.calc\n    def parsed_file():\n        if input.file1() is None:\n            return pd.DataFrame()\n        else: #Note the ui passes only paths ending in  .csv, .CSV, .dta, and .DTA\n            fpath = str(input.file1()[0]['datapath'])\n            if (fpath[-4:] == '.csv') or (fpath[-4:] == '.CSV'):\n                #use this to create an option for extra large files to guess types from the first 1000 rows\n                ##df1 = pd.read_csv(input.file1()[0][\"datapath\"],nrows = 1000)\n                ##dataDict = dict(zip(list(df1.dtypes.index),list(df1.dtypes)))\n                ##df = pd.read_csv(input.file1()[0][\"datapath\"],dtype = dataDict)\n                df = pd.read_csv(input.file1()[0][\"datapath\"])\n            else:\n                df = pd.read_stata(input.file1()[0][\"datapath\"])\n            pushlog(\"************************************************\")\n            pushlog(\"File read: \"  + input.file1()[0]['name'])\n            pushlog(f\"....Number of rows: {len(df)}\")\n            pushlog(\"************************************************\")\n            stemp = df.isna().sum().sum()\n            df.replace('',np.nan,inplace = True)\n            stemp = df.isna().sum().sum() - stemp\n            nona = sum(df.isna().sum(axis=1) >0)\n            if (stemp > 0) | (nona > 0):\n                #io_msgstr.set(f\" {stemp} blank entries converted to NaNs. {nona} rows out of {len(df)} have missing data.\")\n                pushlog(f\" {stemp} blank entries converted to NaNs. {nona} rows out of {len(df)} have missing data.\")\n                \n            #get rid of spaces in column names\n            df.columns = df.columns.str.lstrip()\n            df.columns = df.columns.str.rstrip()\n            df.columns = df.columns.str.replace(' ','_')\n            #change names to avoid collisions with protected names\n            df.columns = [collisionAvoidance(item,protected_names) for item in df.columns]\n            if (input.killna() == 'Yes') : \n                pushlog(\"Rows with missing values dropped on input by user request.\")\n                df.dropna(inplace = True)\n            #reset plotting data\n            plt_data.set(df)\n            #reset current model\n            with reactive.isolate():#reset any current linear model\n                pushlog2(f\"In parsed_file, mdl_stringM() = {mdl_stringM()} resetting model.\")\n                mdl.set(None) #reset statsmodels result\n                ui.update_selectize('depvar',selected = []) #reset dependent variable choices\n                ui.update_selectize('indvar',selected = '-') #rset independent variable choices\n                ui.update_radio_buttons('datachoose', selected = 'Input Data')\n                ui.update_radio_buttons('mtype',selected = 'OLS')\n                mdl_stringM.set('- ~') #reset model string\n                mdl_data.set(pd.DataFrame()) #reset the model dataset\n            return df\n\n    @render.data_frame\n    def info():\n        #print(\"Render Info\")\n        df = parsed_file()\n        #df = plt_data()\n        if df.empty:\n           return \n        #display df.info\n        buffer = io.StringIO()\n        df.info(buf=buffer)\n        slst = buffer.getvalue().splitlines()\n        sdf = pd.DataFrame([item.split() for item in slst[5:-2]],columns = slst[3].split())\n        return sdf\n    \n    @render.data_frame\n    def summary():\n        #print(\"Render Data Frame summary\")\n        df = parsed_file()\n        #df = plt_data()\n        if df.empty:\n            return pd.DataFrame()\n        elif len(df) > 500000:\n            return pd.DataFrame({'': ['Too many rows','Use \\\"summary() \\\" from command line.']},index = ['Problem: ','Solution: '])\n\n        description = df.describe(include= \"all\")\n        dindex = description.index.values\n        description.insert(0,\" \",dindex)\n        return description\n    \n    @render.data_frame\n    def data():\n        #print(\"Render Data Frame\")\n        df = parsed_file()\n        if len(df) > 100000 : return\n        return df\n    \n##########################################################################\n####  Correlations panel\n##########################################################################\n    \n    @render.plot\n    @reactive.event(input.corrV)\n    def dataPD():\n        #print(\"Setup correlations\")\n        if input.corrV() == (): return\n        df = plt_data()\n        fig = plt.figure(figsize = (9,9))\n        showC = input.corrV()\n        showC = [item for item in showC]\n        dfc = df[showC].copy()\n        dfc.dropna(inplace = True)\n        nobs = len(dfc)\n        ax = sb.PairGrid(dfc, vars = showC, corner = True).set(title = f\"# Obs.= {nobs}\")\n        ax.map_diag(sb.histplot, kde=True)\n        ax.map_lower(plt.scatter, s= 2)\n        ax.map_lower(doCorr)\n        return \n\n##########################################################################\n####  Plotting panel\n##########################################################################\n    @reactive.effect\n    @reactive.event(input.datachoose)\n    def data_update():\n        pushlog(\"data_update\")\n        with reactive.isolate():\n            if (input.datachoose() == 'Model Data') :\n                pushlog(\"...Switching to model data.\")\n                plt_data.set(mdl_data())\n            if (input.datachoose() == 'Input Data'):\n                pushlog(\"...Switching to original input data.\")\n                ui.update_radio_buttons(\"datachoose\",label = \"Data:\",choices = [\"Input Data\"])\n                plt_data.set(parsed_file())\n\n\n    @reactive.effect\n    @reactive.event(parsed_file, input.datachoose)\n    def setupPlot():\n        pushlog(\"Initializing Plotting Data (setupPlot)\")\n        df = pd.DataFrame()\n        df = plt_data()\n        nrow = len(df)\n        if (nrow == 0): \n            pushlog(f\"...{nrow} rows in current data, data source = {input.datachoose()}\")\n            return\n        cols = list(df.columns)\n        num_var = list(df.select_dtypes(include=np.number).columns)\n        str_var = [item for item in cols if item not in num_var]   \n        pushlog2(f\"Numerical vars: {'; '.join(num_var)}\") \n        pushlog2(\"...\")\n        pushlog2(f\"String  vars: {'; '.join(str_var)}\") \n        pushlog2(\"...\")\n        #fct used for subsetting (fct short for factor) and coloring\n        fct_var = [item for item in cols if ((item not in num_var) or (len(list(df[item].unique()))<=max_factor_values))]\n        pushlog2(f\"Factor vars: {'; '.join(fct_var)}\") \n        #subset dictionary\n        pushlog2(\"...Initializing filters.\")\n        newdict = {}                \n        newdict = {item: list(map(str,list(df[item].unique()))) for item in fct_var}\n        subdict.set(newdict)\n        num_fct = [item for item in list(df.columns) if (item in num_var) and len(list(df[item].unique())) <= max_factor_values]\n        pushlog(\"...Initializing plotting data.\")\n        ui.update_selectize(\"xvar\",choices = ['-']+num_var)\n        ui.update_selectize(\"yvar\",choices = ['-']+num_var)\n        ui.update_selectize(\"zvar\",choices = ['-']+num_var)\n        ui.update_selectize(\"cvar\",choices = ['-']+fct_var)\n        ui.update_selectize(\"fvar\",choices = ['-']+fct_var)\n        ui.update_selectize(\"corrV\", choices = num_var, selected = None)\n        #if (input.datachoose() == 'Input Data'):\n        if 1 >0 :\n            pushlog(\"... initializing model data\")\n            if (input.datachoose() == \"Input Data\"):\n                ui.update_selectize(\"indvar\",choices = num_var + str_var)\n                ui.update_selectize(\"depvar\",choices =  ['-'] + num_var)\n                ui.update_selectize(\"tofactor\",choices =  num_fct) \n                mdl.set(None)\n            else: \n                ui.update_selectize(\"indvar\", choices = num_var + str_var,selected = list(mdl_indvar()))\n                ui.update_selectize(\"depvar\", choices =  ['-'] + num_var,selected = mdl_depvar())\n                ui.update_selectize(\"tofactor\",choices =  num_fct,selected = list(input.tofactor())) \n\n        pushlog(\"...Initializing extra variables.\")\n        ui.update_selectize(\"w1var\",choices = ['-'] + num_var)        \n        ui.update_selectize(\"w2var\",choices = ['-'] + num_var)        \n        ui.update_selectize(\"w3var\",choices = ['-'] + num_var)        \n        ui.update_selectize(\"w4var\",choices = ['-'] + num_var)        \n        ui.update_selectize(\"w5var\",choices = ['-'] + num_var)        \n        ui.update_selectize(\"w6var\",choices = ['-'] + num_var)      \n        pushlog2(\"...setupPlot returning\")  \n        return\n    \n    #event observer to update subsetting dictionary\n    @reactive.effect\n    @reactive.event(input.fvar)\n    def newfilter():\n        df = plt_data()\n        pushlog2(\"newfilter()\")\n        if len(df) == 0: return\n        #if fvar is not set, restore all rows\n        if (input.fvar() == '-'): \n            pushlog2(\"...Resetting row filter, all rows active.\")\n            #fct used for subsetting (fct short for factor)\n            cols = list(df.columns)\n            num_var = list(df.select_dtypes(include=np.number).columns)\n            fct_var = [item for item in cols if ((item not in num_var) or (len(list(df[item].unique()))<=max_factor_values))]\n            #fctc_var = [item for item in fct_var if (len(list(df[item].unique()))<=5)]#10\n            fct_var.insert(0,\"-\")\n            #fctc_var.insert(0,\"-\")\n            newdict = {}\n            newdict = {item: list(map(str,list(df[item].unique()))) for item in fct_var if item != '-'}\n            subdict.set(newdict)\n            ui.update_selectize(\"fitems\",choices = [], selected = [])\n            return\n        fv = input.fvar()\n        inc_items = list(df[fv].astype('str').unique())\n        ui.update_selectize(\"fitems\", choices = inc_items, selected = inc_items)\n\n    @reactive.effect\n    @reactive.event(input.fitems)\n    def subdict_update():\n        pushlog2(\"subdict_update()\")\n        #update the dictionary of currently active rows keys=col names values = lists of active row values\n        fv = input.fvar()\n        if (fv == '-'): return\n        newdict = subdict()\n        newdict[fv] = list(input.fitems())\n        subdict.set(newdict)\n        pushlog(f\"...Plot dictionary update:  Var = {fv}; Active values: {', '.join(newdict[fv])}\")\n\n    #displays log of currently active rows\n    @render.text\n    @reactive.event(input.updateB,input.fvar,input.xvar, input.yvar, input.zvar, input.cvar)\n    def log(): \n        if (plt_data().empty): return\n        df = plt_data()\n        cols = df.columns\n         #take out the rows that the user has decided to ignore\n        for item in list(subdict().keys()):\n            df = df[df[item].astype('str').isin(list(subdict()[item]))]\n        num_var = list(df.select_dtypes(include=np.number).columns)\n        fct_var = [item for item in cols if ((item not in num_var) or (len(list(df[item].unique()))<=max_factor_values))]\n        newdict = {}\n        newdict = {item: list(map(str,list(df[item].unique()))) for item in fct_var} \n        pushlog2(\"log(): show active rows\")\n        if 1==1: #input.fvar() != '-':\n            return '\\n'.join([f'{item}: {newdict[item]}' for item in newdict.keys()])\n        else:\n            return \"\"\n        \n    @reactive.effect    \n    @reactive.event(input.xvar)\n    def do_xvar():\n        if input.xvar() == '-': \n            plt.clf()\n            return\n        df = plt_data()\n        ui.update_numeric(\"xlb\",value = min(df[input.xvar()]))\n        ui.update_numeric(\"xub\",value = max(df[input.xvar()]))\n\n    @reactive.effect    \n    @reactive.event(input.yvar)\n    def do_yvar():\n        if input.yvar() == '-': \n            plt.clf()\n            return\n        df = plt_data()\n        #ui.update_slider('sl1',label=\"Dot Size:\",min=0.25,max=10.0,value=2.0,step=0.25)\n        ui.update_numeric(\"ylb\",value = min(df[input.yvar()]))\n        ui.update_numeric(\"yub\",value = max(df[input.yvar()]))\n        \n    @reactive.effect    \n    @reactive.event(input.zvar)\n    def do_zvar():\n        if input.zvar() == '-': \n            plt.clf()\n            return\n        df = plt_data()\n        ui.update_numeric(\"zlb\",value = min(df[input.zvar()]))\n        ui.update_numeric(\"zub\",value = max(df[input.zvar()]))  \n\n        \n    # @render.text\n    # def debug():\n    #     return(dbgstr())\n        \n    #adjust ui to reflect number of variables (x only histogram/boxplot)   x and y or x,y and z scatterplot \n    @render.ui\n    @reactive.event(input.xvar, input.yvar,input.zvar)\n    def pltopts():\n        df = plt_data()\n        mxbin = len(df)\n        if ((input.yvar() != '-') & (input.xvar() != '-') & (input.zvar() != '-')):\n            if (input.datachoose() == 'Model Data')  & (set(input.indvar()) == set([input.xvar(),input.yvar()])) & (input.depvar() == input.zvar()):\n                trendOn.set(True)\n                return ui.TagList(\n                              #ui.column(1,offset = 0,*[ui.input_action_button(\"updateB3\", \"Update\")]),\n                              ui.column(3,offset=0,*[ui.input_slider(\"sl1\",\"# dotsize\",min = 0, max = 40, value = 10)]),\n                              ui.column(1,offset = 0,),\n                              ui.column(4,offset=0,*[ui.input_checkbox_group(\"scttropts\",\"3D Scatter Plot Options:\",\n                                                choices=('Show Trend','CI','PI'),selected=(),inline = True)])\n                              )\n            else:\n                trendOn.set(False)\n                return ui.TagList(\n                              #ui.column(1,offset = 0,*[ui.input_action_button(\"updateB12\", \"Update\")]),\n                              ui.column(3,offset=0,*[ui.input_slider(\"sl1\",\"# dotsize\",min = 0, max = 40, value = 10)]),\n                              #ui.column(1,offset = 0,),\n                              #ui.column(2,offset=0,*[ui.input_checkbox_group(\"scttropts\",\"Scatter Plot Options:\",\n                              #                                      choices=('Show Trend','CI','PI'),selected=(),inline = True)])\n                              )\n        elif (input.yvar() != '-') & (input.xvar() != '-'):  \n            if (input.datachoose() == 'Model Data') & (set([input.xvar()])== set(input.indvar())) & (input.yvar() == input.depvar()):\n                trendOn.set(True)\n                return ui.TagList(\n                              #ui.column(1,offset = 0,*[ui.input_action_button(\"updateB12\", \"Update\")]),\n                              ui.column(3,offset=0,*[ui.input_slider(\"sl1\",\"# dotsize\",min = 0, max = 40, value = 10)]),\n                              ui.column(1,offset = 0,),\n                              ui.column(2,offset=0,*[ui.input_checkbox_group(\"scttropts\",\"Scatter Plot Options:\",\n                                                                    choices=('Show Trend','CI','PI'),selected=(),inline = True)])\n                              )\n            else:\n                trendOn.set(False)\n                return ui.TagList(\n                              #ui.column(1,offset = 0,*[ui.input_action_button(\"updateB12\", \"Update\")]),\n                              ui.column(3,offset=0,*[ui.input_slider(\"sl1\",\"# dotsize\",min = 0, max = 40, value = 10)]),\n                              #ui.column(1,offset = 0,),\n                              #ui.column(2,offset=0,*[ui.input_checkbox_group(\"scttropts\",\"Scatter Plot Options:\",\n                              #                                      choices=('Show Trend','CI','PI'),selected=(),inline = True)])\n                              )               \n        elif(input.xvar() != '-'):\n            return ui.TagList(\n                              #ui.column(1,offset = 0,*[ui.input_action_button(\"updateB12\", \"Update\")]),\n                              ui.column(3,offset=0,*[ui.input_radio_buttons(\"rb1\",\"Plot type:\",choices = ['Histogram','Boxplot','Kernel Density'],selected = 'Histogram',inline=True)]),\n                              ui.column(2,offset=0,*[ui.input_numeric(\"sl1\",\"# Bins\",value=min(max(round(mxbin**0.33,0),10),50), width=2)])\n                              )\n        else:\n            return None\n    \n    @render.ui\n    @reactive.event(input.updateB, input.zvar)\n    def grphopts():\n        if(input.zvar()!= '-') :\n            return ui.TagList(ui.column(12,offset=0,*[output_widget(\"plot3\")])\n                              )\n        else:\n            return ui.TagList(ui.column(12,offset=0,*[ui.output_plot(\"Plots\", width = '900px', height = '600px')])\n                              )  \n        \n    def doTrend():\n        dfg = plt_data()\n        with reactive.isolate():\n            cur_mdl = mdl()\n            xv = input.xvar()\n            yv = input.yvar()\n            zv = input.zvar()\n            res = None\n            MTYPE = None\n            #set up the input data for the independent variables\n            sq = 0.05\n            gridcount = 25\n            if (xv != '-'):\n                deltax = dfg[xv].max() - dfg[xv].min()\n                xlo = dfg[xv].min() - sq*deltax\n                xup = dfg[xv].max() + sq*deltax\n            if (yv != '-'): \n                deltay = dfg[yv].max() - dfg[yv].min()\n                ylo = dfg[yv].min() - sq*deltay\n                yup = dfg[yv].max() + sq*deltay\n            if (zv != '-'): #We are doing 3D\n                xvar, yvar = np.meshgrid(np.arange(xlo,xup,deltax/gridcount),np.arange(ylo, yup,deltay/gridcount))                \n                exog0 = pd.DataFrame({xv: xvar.ravel(), yv: yvar.ravel()}) \n            else: #we are doing 2D\n                xvar = np.arange(xlo, xup, deltax/gridcount) \n                yvar = []                      \n                exog0 = pd.DataFrame({xv : xvar})\n            #the data is set now either find an extant model or fit a model\n            #if the x, y and z variables perfectly match the variables in the most recently estimated model, then use that model's results \n            #otherwise fit a new model\n            depV = \"\".join(mdl_stringM().split()).split('~')[0]\n            indV = \"\".join(mdl_stringM().split()).split('~')[1].split('+')\n            res = mdl()\n            MTYPE = mdl_type()\n            try:\n                res_predictions = res.get_prediction(exog=exog0,transform = True)\n                res_frame = res_predictions.summary_frame(alpha = input.siglev())\n            except:\n                pushlog(\"...Predictions failed!\")\n                pushlog2(\"...Prediction data: \")\n                pushlog2(f\"...  {exog0.head()}\")\n                pushlog(\"...In order to plot a trend. \\n ...Plotting variables and model variables must by identical \\n (1 variable and 2 variable models only)\")\n                return [],[],[],[],[],[],[]\n            znew = res_frame['mean'].values.reshape(xvar.shape)    \n            Ci_lb1 =  res_frame['mean_ci_lower'].values.reshape(xvar.shape)\n            Ci_ub1 =  res_frame['mean_ci_upper'].values.reshape(xvar.shape)\n            if (MTYPE == 'OLS'):\n                Pi_lb1 =  res_frame['obs_ci_lower'].values.reshape(xvar.shape)\n                Pi_ub1 =  res_frame['obs_ci_upper'].values.reshape(xvar.shape)\n            else:\n                Pi_lb1 = []\n                Pi_ub1 = []\n            return xvar, yvar, znew, Ci_lb1, Ci_ub1, Pi_lb1, Pi_ub1\n   \n    @output\n    @render_widget\n    @reactive.event(input.updateB)\n    def plot3():\n        pushlog2(\"plot3()\")\n        plt.clf()\n        if (input.xvar() == '-') | (input.yvar() == '-') | (input.zvar() == '-'): return\n        df = plt_data()\n        if len(df) == 0: \n#            plt_msgstr.set(\"You need a data set before you can plot.\")\n            return\n        xv = input.xvar()\n        yv = input.yvar()\n        zv = input.zvar()\n        w1v = input.w1var()\n        w2v = input.w2var()\n        w3v = input.w3var()\n        w4v = input.w4var()\n        w5v = input.w5var()\n        w6v = input.w6var()\n        totrow = len(df)\n        cv = input.cvar()\n        #print(f\"Plotting: x = {xv}, y={yv}, z={zv}, color = {cv} \")\n        if cv == '-': cv = None \n         #take out the rows that the user has decided to ignore\n        for item in list(subdict().keys()):\n            df = df[df[item].astype('str').isin(list(subdict()[item]))]\n        nrow0 = len(df)\n        dfg = df.dropna(subset = [xv, yv, zv]) #get rid fo rows with na's in the columns to be plotted\n        nrow = len(dfg)\n        #plotly can only plot up to about 400,000 to 450,000 rows of data, randomly downsample if needed.  Warn user in the title & log\n        if nrow > 400000:\n            dfg = dfg.sample(400000)\n            nrow = len(dfg)\n            ttlstr = f\"File: {input.file1()[0]['name']} <br> down-sampled!  {nrow} rows plotted out of {totrow} \"\n            pushlog(\"...Plotly 3D plotting limit warning! Attempted to plot {nrow} rows, downsampled to 400,000 rows.\")\n        else:\n            ttlstr = f\"File: {input.file1()[0]['name']}:  {nrow} rows plotted out of {totrow} \"\n            pushlog(f\"...plot3: {totrow-nrow0} rows filtered out, {nrow0-nrow} rows removed due to missing data.\")\n        if input.titleplt() != \"-\" :\n            ttlstr = input.titleplt()\n        if (cv != None):\n            nucolor ,nupatches, colorD = getcolor(list(dfg[cv].astype('str'))) #fix tup color map\n            fig = go.Figure(data = go.Scatter3d(x=dfg[xv],y=dfg[yv],z=dfg[zv],mode='markers',marker= dict(color=nucolor)))\n        else:\n            fig = go.Figure(data = go.Scatter3d(x=dfg[xv],y=dfg[yv],z=dfg[zv],mode='markers'))\n        fig.layout.scene.aspectratio = {'x':1, 'y':1, 'z':1}\n        fig.update_layout(autosize = False,width = 900, height=900,title = ttlstr)\n        fig.update_layout(scene = dict( xaxis_title = xv, yaxis_title = yv, zaxis_title = zv))\n        fig.update_traces(marker = dict(size = int(input.sl1()/5 +1))) # fix up dot size\n        if trendOn():\n            if  \"Show Trend\" in input.scttropts(): \n                xvars, yvars, znew, Ci_lb1, Ci_ub1, Pi_lb1, Pi_ub1 = doTrend() \n                if len(znew) >0:                                \n                    #we are ready to add the traces\n                    fig.add_trace(go.Surface(x=xvars,y=yvars,z=znew, opacity = 0.75,showscale = False)) #dict(orientation = 'h')))\n                    if ('CI' in input.scttropts()):\n                        fig.add_trace(go.Surface(x=xvars,y=yvars,z=Ci_lb1, opacity = 0.75,showscale = False)) #dict(orientation = 'h')))\n                        fig.add_trace(go.Surface(x=xvars,y=yvars,z=Ci_ub1, opacity = 0.75,showscale = False)) #dict(orientation = 'h')))\n                    if ('PI' in input.scttropts()) & (len(Pi_lb1) >0):\n                        fig.add_trace(go.Surface(x=xvars,y=yvars,z=Pi_lb1, opacity = 0.75,showscale = False)) #dict(orientation = 'h')))\n                        fig.add_trace(go.Surface(x=xvars,y=yvars,z=Pi_ub1, opacity = 0.75,showscale = False)) #dict(orientation = 'h')))\n                else:\n                    pushlog(\"...Trend calculation failed. Model variables and plotting variables must match.  Check and re-run model.\")           \n        if (w1v != '-'):\n            dfg = dfg.dropna(subset = [w1v]) #get rid fo rows with na's in the columns to be plotted\n            if (input.w1mark() == 'dot'):\n                fig.add_trace(go.Scatter3d(x = dfg[xv], y = dfg[yv], z = dfg[w1v],mode = 'markers', marker = dict(size = int(input.sl1()/5 +1),color = input.w1col())))\n                pushlog2(f\"...3D extra plot #1 variable= {input.w1var()} color = {input.w1col()} NOTE: missing values are dropped.\")\n            elif (input.w1mark() == 'line'):\n                pushlog2(f\"...3D extra plot #1  variable= {input.w1var()} color = {input.w1col()} NOTE: missing values are dropped.\")\n                fig.add_trace(go.Mesh3d( x = dfg[xv], y = dfg[yv], z = dfg[w1v],color = input.w1col(), opacity = 0.6))\n        if (w2v != '-'):\n            dfg = dfg.dropna(subset = [w2v]) #get rid fo rows with na's in the columns to be plotted\n            if (input.w2mark() == 'dot'):\n                fig.add_trace(go.Scatter3d(x = dfg[xv], y = dfg[yv], z = dfg[w2v],marker = dict(size = int(input.sl1()/5 +1),color = input.w1col())))\n                pushlog2(f\"...3D extra plot #2 variable= {input.w2var()} color = {input.w2col()} NOTE: missing values are dropped.\")\n            elif (input.w2mark() == 'line'):\n                pushlog2(f\"...3D extra plot #2  variable= {input.w2var()} color = {input.w2col()} NOTE: missing values are dropped.\")\n                fig.add_trace(go.Mesh3d( x = dfg[xv], y = dfg[yv], z = dfg[w2v],color = input.w1col()))\n        if (w3v != '-'):\n            dfg = dfg.dropna(subset = [w3v]) #get rid fo rows with na's in the columns to be plotted\n            if (input.w3mark() == 'dot'):\n                fig.add_trace(go.Scatter3d(x = dfg[xv], y = dfg[yv], z = dfg[w3v],marker = dict(size = int(input.sl1()/5 +1),color = input.w1col())))\n                pushlog2(f\"...3D extra plot #3 variable= {input.w3var()} color = {input.w3col()} NOTE: missing values are dropped.\")\n            elif (input.w3mark() == 'line'):\n                pushlog2(f\"...3D extra plot #3  variable= {input.w3var()} color = {input.w3col()} NOTE: missing values are dropped.\")\n                fig.add_trace(go.Mesh3d( x = dfg[xv], y = dfg[yv], z = dfg[w3v],color = input.w1col()))\n        if (w4v != '-'):\n            dfg = dfg.dropna(subset = [w4v]) #get rid fo rows with na's in the columns to be plotted\n            if (input.w4mark() == 'dot'):\n                fig.add_trace(go.Scatter3d(x = dfg[xv], y = dfg[yv], z = dfg[w4v],marker = dict(size = int(input.sl1()/5 +1),color = input.w1col())))\n                pushlog2(f\"...3D extra plot #4 variable= {input.w4var()} color = {input.w4col()} NOTE: missing values are dropped.\")\n            elif (input.w4mark() == 'line'):\n                pushlog2(f\"...3D extra plot #4  variable= {input.w4var()} color = {input.w4col()} NOTE: missing values are dropped.\")\n                fig.add_trace(go.Mesh3d( x = dfg[xv], y = dfg[yv], z = dfg[w4v],color = input.w1col()))\n        if (w5v != '-'):\n            dfg = dfg.dropna(subset = [w5v]) #get rid fo rows with na's in the columns to be plotted\n            if (input.w5mark() == 'dot'):\n                fig.add_trace(go.Scatter3d(x = dfg[xv], y = dfg[yv], z = dfg[w5v],marker = dict(size = int(input.sl1()/5 +1),color = input.w1col())))\n                pushlog2(f\"...3D extra plot #5 variable= {input.w5var()} color = {input.w5col()} NOTE: missing values are dropped.\")\n            elif (input.w5mark() == 'line'):\n                pushlog2(f\"...3D extra plot #5  variable= {input.w5var()} color = {input.w5col()} NOTE: missing values are dropped.\")\n                fig.add_trace(go.Mesh3d( x = dfg[xv], y = dfg[yv], z = dfg[w5v],color = input.w1col()))\n        if (w6v != '-'):\n            dfg = dfg.dropna(subset = [w6v]) #get rid fo rows with na's in the columns to be plotted\n            if (input.w6mark() == 'dot'):\n                fig.add_trace(go.Scatter3d(x = dfg[xv], y = dfg[yv], z = dfg[w6v],marker = dict(size = int(input.sl1()/5 +1),color = input.w1col())))\n                pushlog2(f\"...3D extra plot #6 variable= {input.w6var()} color = {input.w6col()} NOTE: missing values are dropped.\")\n            elif (input.w6mark() == 'line'):\n                pushlog2(f\"...3D extra plot #6  variable= {input.w6var()} color = {input.w6col()} NOTE: missing values are dropped.\")\n                fig.add_trace(go.Mesh3d( x = dfg[xv], y = dfg[yv], z = dfg[w6v],color = input.w1col()))\n        return fig\n                \n    @render.plot\n    @reactive.event(input.updateB)\n    def Plots():\n        pushlog(\"Plots\")\n        if (input.zvar() != '-') : return # plotting happening in plot3()\n        if (input.xvar() == '-'):\n            plt.clf()\n            return\n        plt.clf()\n        df = plt_data()\n        if len(df) == 0: \n#            plt_msgstr.set(\"You need a data set before you can plot.\")\n            return\n        xv = input.xvar()\n        yv = input.yvar()\n        zv = input.zvar()\n        totrow = len(df)\n        cv = input.cvar()\n        pushlog2(f\"...plotting x = {xv}, y = {yv}, color = {cv}\")\n        #print(f\"Beginning of plots ...Model: {mdl_stringM()} indvar = {mdl_indvar()}  depvar = {mdl_depvar()}\")\n        #expand the plot axes a squidge for esthetics\n        squidgeVal = 0.05\n        if (xv != '-'):\n            squidgeX = (input.xub()-input.xlb())*squidgeVal\n        if (yv != '-'):\n            squidgeY = (input.yub()-input.ylb())*squidgeVal\n        #create the row subset for plotting     \n        for item in list(subdict().keys()):\n           df = df[df[item].astype('str').isin(list(subdict()[item]))]\n        nrow1 = len(df)\n        pushlog(f\"...{totrow-nrow1} rows excluded via filter.\")\n        #drop rows that have NaN values in the columns to be plotted\n        sbst = [xv]\n        if yv != '-': sbst.append(yv)\n        if zv != '-': sbst.append(zv)\n        dfg = df.dropna(subset = sbst)\n        nrow = len(dfg)\n        pushlog(f\"...{nrow1 - nrow} rows dropped from plotting set due to missing data.\")\n        if (cv != '-'):\n            colorlist,lpatches,colorD = getcolor(list(dfg[cv].astype('str')))\n            color_data = dfg[cv].astype('str')\n        else:\n            cv = None\n            colorlist = None\n            color_data = None    \n        fig = plt.figure(2,figsize = (12,9), tight_layout = False)\n        fig.clf()\n        #make this a user choice later\n        sb.set_style(\"darkgrid\", {\"grid.color\": \".6\", \"grid.linestyle\": \":\"})\n        #initialize some parameters\n        edgecol = 'black'\n        kdeflag = False\n        titlestr = f'File: {input.file1()[0][\"name\"]} rows shown {nrow} out of {totrow}'        \n        if  ((xv != '-') & (yv != '-')):\n            #numx = dfg[xv].unique\n            ax=sb.scatterplot(data = dfg,x = xv,y = yv, c = colorlist,  s = input.sl1(),label = yv)\n            if yv == 'Residuals':\n                plt.axhline(y = 0, color = 'black')\n            #print(f\".....Just before Show Trend in plots mdl_indvar = {list(mdl_indvar())}, model: {mdl_stringM()}, input.indvar = {list(input.indvar())}, input.depvar = {input.depvar()}\")\n            if trendOn():\n                if \"Show Trend\" in input.scttropts():\n                    xvar, yvar, ynew, Ci_lb1, Ci_ub1, Pi_lb1, Pi_ub1 = doTrend()\n                    if len(ynew) >0: \n                            ax = sb.lineplot(x=xvar, y= ynew, color = 'red') \n                            if ('CI' in input.scttropts()):\n                                ax = sb.lineplot(x = xvar, y= Ci_lb1, color = 'green')\n                                ax = sb.lineplot(x = xvar, y= Ci_ub1, color = 'green')\n                            if ('PI' in input.scttropts()) & (len(Pi_lb1) > 0):\n                                ax = sb.lineplot(x = xvar, y= Pi_lb1, color = 'goldenrod')\n                                ax = sb.lineplot(x = xvar, y= Pi_ub1, color = 'goldenrod')   \n                    else: \n                        pushlog(\"...Trend calculation failed. Plotting variables and model variables must match.  Check data and re-run model. \")  \n\n            # plot extra series if needed                    \n            if (input.w1var() != '-'):\n                if (input.w1mark() == 'dot'):\n                    ax=sb.scatterplot(data = dfg,x = xv,y = input.w1var(), c = input.w1col(),  s = input.sl1(),label = input.w1var())\n                    pushlog2(f\"... extra plot #1 variable= {input.w1var()} color = {input.w1col()} NOTE: missing values are dropped.\")\n                    #ax.add(sb.Dot())    \n                elif (input.w1mark() == 'line'):\n                    pushlog2(f\"... extra plot #1  variable= {input.w1var()} color = {input.w1col()} NOTE: missing values are dropped.\")\n                    ax = sb.lineplot(data= dfg, x=xv, y=input.w1var(), color = input.w1col(),label = input.w1var())\n                    #plt.legend(title = input.w1var(), loc = 1, fontsize = 12)\n            if (input.w2var() != '-'):\n                if (input.w2mark() == 'dot'):\n                    ax=sb.scatterplot(data = dfg,x = xv,y = input.w2var(), c = input.w2col(),  s = input.sl1(),label = input.w2var())\n                    pushlog2(f\"... extra plot #2 variable= {input.w2var()} color = {input.w2col()} NOTE: missing values are dropped.\")  \n                elif (input.w2mark() == 'line'):\n                    pushlog2(f\"... extra plot #2 variable= {input.w2var()} color = {input.w2col()} NOTE: missing values are dropped.\")\n                    ax = sb.lineplot(data= dfg, x=xv, y=input.w2var(), color = input.w2col(),label = input.w2var())\n                    #plt.legend(title = input.w2var(), loc = 1, fontsize = 12)\n            if (input.w3var() != '-'):\n                if (input.w3mark() == 'dot'):\n                    ax=sb.scatterplot(data = dfg,x = xv,y = input.w3var(), c = input.w3col(),  s = input.sl1(),label = input.w3var())\n                    pushlog2(f\"... extra plot #3 variable= {input.w3var()} color = {input.w3col()} NOTE: missing values are dropped.\")  \n                elif (input.w3mark() == 'line'):\n                    pushlog2(f\"... extra plot #3 variable= {input.w3var()} color = {input.w3col()} NOTE: missing values are dropped.\")\n                    ax = sb.lineplot(data= dfg, x=xv, y=input.w3var(), color = input.w3col(),label = input.w3var())\n                    #plt.legend(title = input.w3var(), loc = 1, fontsize = 12)                    \n            if (input.w4var() != '-'):\n                if (input.w4mark() == 'dot'):\n                    ax=sb.scatterplot(data = dfg,x = xv,y = input.w4var(), c = input.w4col(),  s = input.sl1(),label = input.w4var())\n                    pushlog2(f\"... extra plot #4 variable= {input.w4var()} color = {input.w4col()} NOTE: missing values are dropped.\")\n                    #ax.add(sb.Dot())    \n                elif (input.w4mark() == 'line'):\n                    pushlog2(f\"... extra plot #4  variable= {input.w4var()} color = {input.w4col()} NOTE: missing values are dropped.\")\n                    ax = sb.lineplot(data= dfg, x=xv, y=input.w4var(), color = input.w4col(),label = input.w4var())\n                    #plt.legend(title = input.w4var(), loc = 1, fontsize = 12)\n            if (input.w5var() != '-'):\n                if (input.w5mark() == 'dot'):\n                    ax=sb.scatterplot(data = dfg,x = xv,y = input.w5var(), c = input.w5col(),  s = input.sl1(),label = input.w5var())\n                    pushlog2(f\"... extra plot #5 variable= {input.w5var()} color = {input.w5col()} NOTE: missing values are dropped.\")  \n                elif (input.w5mark() == 'line'):\n                    pushlog2(f\"... extra plot #5 variable= {input.w5var()} color = {input.w5col()} NOTE: missing values are dropped.\")\n                    ax = sb.lineplot(data= dfg, x=xv, y=input.w5var(), color = input.w5col(),label = input.w5var())\n                    #plt.legend(title = input.w5var(), loc = 1, fontsize = 12)\n            if (input.w6var() != '-'):\n                if (input.w6mark() == 'dot'):\n                    ax=sb.scatterplot(data = dfg,x = xv,y = input.w6var(), c = input.w6col(),  s = input.sl1(),label = input.w6var())\n                    pushlog2(f\"... extra plot #6 variable= {input.w6var()} color = {input.w6col()} NOTE: missing values are dropped.\")  \n                elif (input.w6mark() == 'line'):\n                    pushlog2(f\"... extra plot #6 variable= {input.w6var()} color = {input.w6col()} NOTE: missing values are dropped.\")\n                    ax = sb.lineplot(data= dfg, x=xv, y=input.w6var(), color = input.w6col(),label = input.w6var())\n            plt.legend(loc = 1, fontsize = 12)                    \n\n            ax.set_title(titlestr)\n            ax.set_xlabel(xv)\n            ax.set_ylabel(yv)\n            ax.set_xlim(input.xlb()-squidgeX,input.xub()+squidgeX)\n            ax.set_ylim(input.ylb()-squidgeY,input.yub()+squidgeY)\n            if (cv != None) :\n                ax.legend(title = cv, handles = lpatches)\n        elif (xv != '-'):\n            if (input.rb1() == 'Boxplot'):\n                ax =sb.boxplot(data = dfg, y=xv,x=color_data, notch = True)\n                #ax =sb.boxplot(data = dfg, y=xv,x=colorlist, notch = True)\n                ax.set_title(titlestr)\n            else: \n               if (input.rb1() == \"Kernel Density\"):\n                   kdeflag = True\n               if (cv != None):\n                   edgecol = None\n               else: edgecol = 'black'\n               ax = sb.histplot(data = dfg, x=xv, hue = color_data, ec = edgecol ,kde = kdeflag,bins=input.sl1())\n               #ax = sb.histplot(data = dfg, x=xv, color = colorlist, ec = edgecol,kde = kdeflag,bins=input.sl1())\n               ax.set_title(titlestr)\n\n               #ax.set_title(f'File: {input.file1()[0][\"name\"]} #rows = {nrow}')\n               ax.set_xlabel(xv)\n               ax.set_xlim(input.xlb()-squidgeX,input.xub()+squidgeX)\n        else: \n            return\n        return plt.draw()\n\n    @render.download(filename=\"plotIt_Plotting_data.csv\")\n    def downloadDP():\n        df = plt_data()\n        print(\"Download plotting data to: plotIt_Plotting_data.csv\")\n        #create the row subset for graphing    \n        for item in list(subdict().keys()):\n            df = df[df[item].astype('str').isin(list(subdict()[item]))]\n        yield df.to_csv(index = False)\n        \n##########################################################################\n####  Linear Models panel\n##########################################################################\n    @render.ui\n    @reactive.event(input.mtype)\n    def nbparm():\n        if (\"NEGATIVE_BINOMIAL\" == input.mtype()):\n            return ui.TagList(*[ ui.input_numeric(\"alphaparm\", \"Negative Binomial: variance parm (between 0.01 and 2.0):\", value=\"1.0\",width=10)])\n        else:\n            return ui.TagList(*[])\n\n    @reactive.effect\n    @reactive.event(input.depvar)    \n    def do_depvar():\n        df = plt_data()        #mdl.set(None)\n        if len(df) == 0: return\n        num_var = list(df.select_dtypes(include=np.number).columns)\n        str_var = list(df.select_dtypes(exclude=np.number).columns)\n        if (input.depvar() == '-'): \n            ui.update_selectize('depvar',choices = ['-'] + num_var)\n            ui.update_selectize('indvar',choices = num_var + str_var)\n        else: \n            indvar_choices = [item for item in num_var+str_var if item != input.depvar()]\n            ui.update_selectize('indvar',choices = indvar_choices)\n        return\n                        \n    @reactive.effect\n    @reactive.event(input.indvar,input.depvar)\n    def doMstring():\n        ui.update_text(\"stringM\",value = f\"{''.join(input.depvar())} ~ {' + '.join(input.indvar())}\")\n        return\n    \n    @reactive.effect\n    @reactive.event(input.modelGo)\n    def runModel():\n        df = plt_data()\n        pushlog(f\"At runModel Top.::::::  input.indvar = {input.indvar()}\")\n        size0 = len(df)\n        if (input.depvar() == '-'): \n            return\n        pushlog(f\"runModel:: Dependent Var: {input.depvar()}, Independent Var: {', '.join(input.indvar())}, model: {input.stringM()}\")\n        #apply the current subset items are column names items are the dictionary keys, \n        #   the dictionary entry is the list of active row values for that column.\n        for item in list(subdict().keys()):\n            df = df[df[item].astype('str').isin(list(subdict()[item]))]\n        size1 = len(df)\n        #create factors for numerical variables as set by user by changing them into strings\n        if len(input.tofactor()) >0 :\n            pushlog(f\"runModel: Creating factors for: {', '.join(input.tofactor())}\")\n        for item in input.tofactor():\n            df[item] = df[item].astype('str')    \n        #manually remove rows containing NaNs in the dependent or independent variables columns\n        df.dropna(subset = [input.depvar()] + list(input.indvar()),inplace = True)   \n        size2 = len(df)   \n        #check to see if the dependent variable is binary (use logit) has several outcomes (use ols) or just one (quit)\n        pushlog(f\".... {size0-size1} rows deleted by filter, {size1-size2} rows deleted due to missing data.\")        \n        #minimal sanity check: a) dependent variable can't be constant b) if LOGIT has been chosen, dependent variable must be binary (0 or 1)\n        outcomes = list(df[input.depvar()].unique())\n        ISINT = False\n        if df[input.depvar()].dtype == 'int':\n            ISINT = True\n        elif df[input.depvar()].dtype == 'float':\n            if (df[input.depvar()].apply(float.is_integer).all()):\n                ISINT = True\n            else:\n                ISINT = False\n        else: \n            ISINT = False\n        pushlog(f\"...Dependent variable type: {df[input.depvar()].dtype}; ISINT = {ISINT}\")\n        no_outcomes = len(outcomes)\n        if (no_outcomes <=1):\n            pushlog(\"The dependent variable is a constant.  I'm confused.  Please check and try again.\")\n            mdl.set(None)\n            return\n        STOP = False\n        if (input.mtype() == 'LOGIT'):\n            if set([0,1]) == set(outcomes) :\n                try:\n                    #res = smf.logit(formula = input.stringM(), data=df).fit()\n                    res = smf.glm(formula = input.stringM(), data = df, family=sm.families.Binomial()).fit()\n                except: \n                    STOP = True\n                mdl_type.set('LOGIT')\n            else:\n                pushlog(\"...Logistic Regression Error: dependent variable not binary 0,1.\")\n                mdl.set(None)\n                return\n        elif (input.mtype() == 'OLS'):\n            try:\n                res = smf.ols(formula=input.stringM(), data=df).fit()\n            except: \n                STOP = True            \n            mdl_type.set('OLS')\n        elif (input.mtype() == 'POISSON') & (min(outcomes) >=0):\n            if (min(outcomes) >= 0) & ISINT:\n                try:\n                    pushlog(f\" ...Estimating model: ISINT= {ISINT}, min outcome = {min(outcomes)}\")\n                    res = smf.glm(formula=input.stringM(), data=df, family = sm.families.Poisson()).fit()\n                except: \n                    STOP = True            \n                mdl_type.set('POISSON')\n            else:\n                pushlog(\"...Poisson Regression Error: dependent variables are not non-negative integers.\")\n                mdl.set(None)\n                return\n        elif (input.mtype() == 'NEGATIVE_BINOMIAL') & (min(outcomes) >=0):\n            if (min(outcomes) >= 0) & ISINT:\n                try:\n                    pushlog(f\" ...Estimating model: ISINT= {ISINT}, min outcome = {min(outcomes)}\")\n                    res = smf.glm(formula=input.stringM(), data=df, family = sm.families.NegativeBinomial(alpha = input.alphaparm())).fit()\n                except: \n                    STOP = True            \n                mdl_type.set('NEGATIVE_BINOMIAL')\n            else:\n                pushlog(\"...Negative Binomial Regression Error: dependent variables are not non-negative integers.\")\n                mdl.set(None)\n                return\n        else:\n            STOP = True\n            pushlog(\"No model chosen. Choose OLS, LOGIT, POISSON, or NEGATIVE BINOMIAL\")\n        if STOP:\n            mdl_indvar.set([])\n            mdl_depvar.set('-')\n            mdl.set(None)\n            ui.update_radio_buttons(\"datachoose\",choices = ['Input Data','Model Data'],selected = None)\n            pushlog(f\"{mdl_type()} estimation failed. Model = {input.stringM()} \")\n            return\n        # regression succeeded          \n        mdl.set(res) \n        mdl_d = pd.concat([res.model.data.orig_exog,res.model.data.orig_endog],axis = 1)\n        \n        if (mdl_type() != 'OLS') :\n            prediction_res = res.get_prediction(transform = True)\n            res_frame= prediction_res.summary_frame(alpha = input.siglev())\n            mdl_d['CI_lb'] =  res_frame['mean_ci_lower']\n            mdl_d['CI_ub'] =  res_frame['mean_ci_upper']\n            #mdl_d['PI_lb'] =  res_frame['obs_ci_lower']\n            #mdl_d['PI_ub'] =  res_frame['obs_ci_upper']\n            mdl_d['Predictions'] = res_frame['mean']\n            mdl_d['Deviance_Resid'] = res.resid_deviance\n        elif (mdl_type()=='OLS'):\n            prediction_res = res.get_prediction(transform  = True)\n            res_frame= prediction_res.summary_frame(alpha = input.siglev())\n            mdl_d['CI_lb'] =  res_frame['mean_ci_lower']\n            mdl_d['CI_ub'] =  res_frame['mean_ci_upper']\n            mdl_d['PI_lb'] =  res_frame['obs_ci_lower']\n            mdl_d['PI_ub'] =  res_frame['obs_ci_upper']\n            mdl_d['Predictions'] = res_frame['mean']\n            mdl_d['Residuals'] =  res.resid\n        addoncols = [item for item in df.columns if item not in mdl_d.columns]\n        #reconvert numeric variables that were turned into strings (and subsequently factors)\n        for item in input.tofactor():\n            df[item] = pd.to_numeric(df[item])    \n        #prepare the data set for applying the plotting tools to the model\n        pushlog(f\"...Model data columns: {','.join(mdl_d.columns)}\")\n        pushlog(f\"...Extra data columns: {','.join(addoncols)}\")\n        mdl_d = pd.concat([mdl_d,df[addoncols]],axis = 1)\n        mdl_data.set(mdl_d)\n        mdl_indvar.set(input.indvar())\n        mdl_depvar.set(input.depvar())\n        mdl_stringM.set(input.stringM())\n        #now setup the standard plots\n        ui.update_select(\"lmsp\",choices = ['-'] + list(res.params.index),selected = None)\n        if (mdl_type() == 'LOGIT'):\n            ui.update_radio_buttons(\"regplotR\",choices = ['ROC', 'Partial Regression','Fit'], selected = 'ROC')\n        elif(mdl_type() == 'OLS'):\n            if (len(input.depvar()) < 12000):\n                ui.update_radio_buttons(\"regplotR\",choices = ['Leverage','Partial Regression','Influence','Fit'],selected = 'Leverage')\n            else:\n                ui.update_radio_buttons(\"regplotR\",choices = ['Partial Regression','Fit'],selected = 'Partial Regression')\n        else:\n                ui.update_radio_buttons(\"regplotR\",choices = ['Partial Regression','Fit'],selected = 'Partial Regression')\n\n        #set up data choice (input data or mode data) on the plotting tab\n\n        ######Kludge to simulate the user choosing 'Model Data' post model estimation\n        with reactive.isolate(): #first we change the 'datachoose\" choice to 'None' but we hide it\n            ui.update_radio_buttons(\"datachoose\",choices = ['Input Data', 'Model Data'],selected = None)\n        #then we choose 'Model Data' but we don't hide it -- this triggers dataUpdate() and setupPlot() to initialize the model data as the  plotting data.\n        ui.update_radio_buttons(\"datachoose\",label = \"Data: (selecting Input Data clears model)\",choices = ['Input Data','Model Data'],selected = 'Model Data')\n        \n        pushlog(f\"Estimation successful. {mdl_type()} ...Model: {mdl_stringM()}\")\n        #pushlog(str( mdl().summary()))\n        return\n    \n    @render.text\n    @reactive.event(input.modelGo,mdl)\n    def modelSummary():\n        if (mdl() == None) :\n            outstring = f\"Model estimation failed or model cleared.  Check log for details. model: {input.stringM()}\"\n            return outstring\n        SSstr0 =  \"==============================================================================\"\n        if mdl_type() == 'OLS' :\n            #SSstr1 =  f\"SSE = {round(mdl().ssr,5)}, SSR={round(mdl().ess,5)}, SST = {round(mdl().ssr + mdl().ess,5)}\" \n            #SSstr2 = f\"MSE = {round(mdl().mse_resid,5)}, MSR ={round(mdl().mse_model,5)}, MST = {round(mdl().mse_total,5)} \"   \n            SSstr = SSstr0 + \"\\n\" + \"Model: \" + input.stringM() + \"\\n\\n\" + str( mdl().summary()) + \"\\n\"\n            SSstr = SSstr + SSstr0 + '\\n' + 'Analysis of Variance' + \"\\n\"\n            anova_rep = sm.stats.anova_lm(mdl(),typ=1)          \n            row1 = pd.Series({'df': mdl().df_model, 'sum_sq': mdl().ess,'mean_sq': mdl().mse_model,'F': ' ','PR(>F)':' '},name = 'Regression')\n            row2 = pd.Series({'df': mdl().df_resid + mdl().df_model, 'sum_sq': mdl().ess + mdl().ssr,'mean_sq': mdl().mse_total, 'F': ' ','PR(>F)':' '},name = 'Total')\n            anova_rep.loc['Regression'] = row1\n            anova_rep.loc['Total'] = row2\n            anova_rep.replace(np.nan,\" \")\n            SSstr = SSstr + str(anova_rep[anova_rep.columns[0:len(anova_rep.columns)-2]][-3:]) + '\\n' + SSstr0\n        elif mdl_type() == 'LOGIT' :\n            fpr, tpr, thresholds = roc_curve(mdl_data()[input.depvar()], mdl_data()['Predictions']) \n            roc_auc = auc(fpr, tpr)  \n            SSstr1 = f\" AUC: {roc_auc}\"\n            SSstr = \"Model: \" + input.stringM() + \"\\n\\n\" + str( mdl().summary()) + \"\\n\" + SSstr0 + \"\\n\" + SSstr1 + \"\\n\" + SSstr0\n        else: SSstr = \"Model: \" + input.stringM() + \"\\n\\n\" + str( mdl().summary()) \n        pushlog(SSstr)\n        return SSstr\n        \n    @render.ui\n    @reactive.event(input.modelGo)\n    def dloads():\n        if (mdl() != None):\n            return ui.TagList(\n               ui.column(3,offset = 0,*[ui.download_button(\"downloadD\", \"Download Data Set\")]),\n               )\n        else:\n            return None\n              \n    @render.download(filename=\"plotIt_Model_Data.csv\")\n    def downloadD():\n        yield mdl_data().to_csv(index = False)\n         \n##########################################################################\n####  Linear Models: Standard Plots panel\n##########################################################################       \n    @render.plot\n    #@reactive.event(mdl)\n    def regplot1():\n        if (mdl() == None) : \n            #lm_msgstr.set(\"Run a model using the Linear Model tab before plotting it (first numbers, then pictures)\")\n            return\n        #lm_msgstr.set(\"\")\n        fig = plt.figure(figsize=(8, 8)) \n        if (input.regplotR() == 'Partial Regression'):\n            plot_partregress_grid(mdl(), fig=fig)\n            plt.axhline(y=0)\n            return plt.draw()\n        if (input.regplotR() == 'ROC') :\n            if (mdl_type() != 'LOGIT') : return\n            # Calculate ROC curve\n            if (input.depvar() == '-') :\n                pushlog(f\"Unable to display ROC curve: dependent variable not specified: {input.depvar()}\")\n                return\n            fpr, tpr, thresholds = roc_curve(mdl_data()[input.depvar()], mdl_data()['Predictions']) \n            roc_auc = auc(fpr, tpr)\n            # Plot the ROC curve\n            ax = fig.add_subplot()\n            ax.plot(fpr, tpr)\n            ax.plot([0, 1], [0, 1], 'k--')\n            ax.set_xlim([0.0, 1.0])\n            ax.set_ylim([0.0, 1.05])\n            ax.set_xlabel('False Positive Rate')\n            ax.set_ylabel('True Positive Rate')\n            ax.set_title(f\"ROC  Model: {input.stringM()}, AUC={round(roc_auc,5)}\")\n            return plt.draw()\n        if (input.regplotR() == 'Leverage'):\n            if(mdl_type()!= 'OLS'): return\n            plot_leverage_resid2(mdl())          \n            return plt.draw()\n        if (input.regplotR() == 'Influence'):\n            if mdl_type() != 'OLS' : return\n            influence_plot(mdl(),fig = fig)          \n            return plt.draw()\n        if (input.regplotR() == 'Fit'):\n            ivs = list(mdl().params.index)\n            targetv = input.lmsp()\n            if (targetv in ivs):\n                varno = ivs.index(targetv)  \n                fig = plot_fit(mdl(),varno,vlines = False)\n            else:\n                return\n            fig.tight_layout(pad=1.0)\n            return plt.draw()\n\n#app = App(app_ui, server,debug=True)\napp = App(app_ui, server)\n\n", "type": "text"}]