[{"name": "app.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Apr  2 15:45:31 2024\n\n@author: JM-RPC\n\"\"\"\n#import pdb; pdb.set_trace()\nfrom sklearn.metrics import roc_curve, auc\nimport statsmodels as sm\nimport statsmodels.formula.api as smf\nfrom statsmodels.graphics.regressionplots import plot_partregress_grid, plot_leverage_resid2, influence_plot, plot_fit\nfrom scipy import stats\nimport numpy as np\nimport pandas as pd\nimport io\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport seaborn as sb\nfrom mpl_toolkits.mplot3d import Axes3D\nimport plotly.express as pltx\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\nimport shinywidgets\nfrom shinywidgets import render_widget, output_widget\nimport plotly.express as pltx\nimport plotly.graph_objs as go\nimport os\nimport signal\nfrom datetime import datetime\nfrom shinywidgets import output_widget, render_widget\n\n#import nest_asyncio\n\n\n#from shinywidgets import output_widget, render_widget\n\nmax_factor_values = 25\n\nbasecolors0 = ['red',  'blue', 'green', 'goldenrod', 'violet','cyan', 'yellow','grey','gold','magenta','silver','orange','olive','khaki','thistle']\nbasecolorsalpha = ['red',  'blue', 'green', 'goldenrod', 'violet','cyan', 'yellow','grey','gold','magenta']\nbasecolors = [matplotlib.colors.to_rgba(item,alpha = None) for item in basecolorsalpha]\nprotected_names = ['Residuals','Predictions','Deviance_Resid','CI_lb', 'CI_ub','PI_lb', 'PI_ub']\n\ndef getcolor(col_data):\n    dfc = pd.DataFrame(col_data).astype('str')\n    choicesCo = list(dfc[dfc.columns[0]].astype('str').unique())\n    choicesCo.sort()\n    if (len(choicesCo) < len(basecolors)):\n        colorD = {item : basecolors[choicesCo.index(item)]  for item in choicesCo}\n        colorlist = [colorD[item] for item in col_data]\n        lpatches = [mpatches.Patch(color = colorD[item],label = item) for item in colorD.keys()]\n    else:\n        cmap = plt.cm.plasma\n        #colorNos = [choicesCo.index(item) for item in col_data]\n        colorD = {item : cmap(choicesCo.index(item)/len(choicesCo)) for item in choicesCo}\n        colorlist = [colorD[item] for item in col_data]\n        lpatches = [mpatches.Patch(color = colorD[item],label = item) for item in choicesCo]\n    return colorlist, lpatches, colorD\n\ndef collisionAvoidance(name,namelist):\n    while name in namelist: \n        name = name + '_0'        \n    return(name)\n\ndef doCorr(xv, yv, **kws):\n    r,p = stats.pearsonr(xv,yv)\n    ax = plt.gca()\n    ax.annotate(\"r = {:.3f}, p = {:.3f}\".format(r,p),xy=(.1, .9), xycoords=ax.transAxes)\n\napp_ui = ui.page_navbar( \n    ui.nav_panel(\"Input\",\n        ui.input_file(\"file1\", \"Choose .csv or .dta File\", accept=[\".csv\",\".CSV\",\".dta\",\".DTA\"], multiple=False, placeholder = ''),\n        ui.output_text('io_mess'),ui.input_radio_buttons('killna', 'Remove rows with missing data in one or more columns?',choices = ['No','Yes']),\n        ui.output_text_verbatim(\"info\"), \n        ui.output_table(\"summary\"),\n        ),\n    ui.nav_panel(\"Correlations\",\n                 ui.row(ui.input_selectize(\"corrV\",\"Select variables:\",choices = [''],multiple = True,width = \"200px\")),\n                 ui.output_plot(\"dataPD\",width = '1200px', height = '1200px'),\n                 ),\n    ui.nav_panel(\"Plotting\",\n                 ui.row(\n                     ui.output_text(\"plt_mess\",inline = True)\n                     ),\n                 ui.row(\n                     ui.input_radio_buttons(\"datachoose\",\"Data:\",choices = ['Input Data'], selected = 'Input Data', inline = True),\n                     ),\n                 ui.row(\n                     ui.column(2,offset=0,*[ ui.input_selectize(\"xvar\",\"X variable:\",choices = ['-'], multiple=False)]),\n                     ui.column(2,offset=0,*[ ui.input_selectize(\"yvar\",\"Y variable:\",choices = ['-'], multiple=False)]),\n                     ui.column(2,offset=0,*[ ui.input_selectize(\"zvar\",\"Z variable:\",choices = ['-'], multiple=False)]),\n                     ui.column(2,offset=0,*[ ui.input_selectize(\"cvar\",\"Color with:\",choices = ['-'], multiple=False)]),\n                     ),\n                 ui.row(\n                     ui.column(1,offset=0,*[ui.input_action_button(\"updateB\", \"Update\")]),\n                     ui.column(1,offset=0),\n                     ui.output_ui(\"pltopts\"),\n                     ui.column(1,offset=0),\n                     ui.column(3,offset = 0,*[ui.download_button(\"downloadDP\",\"Save Plotting Data\",width = \"200px\")]),\n                     \n                     ),\n                 ui.row(ui.output_ui(\"grphopts\"),\n                     ),\n                 ui.row(\n                     ui.input_selectize(\"fvar\",\"Filter on:\" ,choices = ['-'], multiple=False),\n                     ui.input_selectize(\"fitems\",\"Included Rows:\",choices = ['-'], multiple=True),\n                     ),\n                 ui.row(\n                        ui.HTML(\"<p>Rows Selected (filter on \\\"-\\\" above to clear filter).</p>\"),\n                     ),\n                 ui.row(\n                     ui.output_text_verbatim(\"log\")\n                     ),\n                 ui.row(\n                        ui.input_text(\"titleplt\",\"Plot Title:\", value = '-', width = '800px', )\n                     ),\n                 ui.row(ui.HTML(\"<p>These bounds override plot bounds.  To reset reselect the variable.</p>\")\n                     ),\n                 ui.row(\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"xlb\", \"X lower bound:\", value=\"\",width=10)]),\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"xub\", \"X upper bound:\", value=\"\",width=10)]),\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"ylb\", \"Y lower bound:\", value=\"\",width=10)]),\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"yub\", \"Y upper bound:\", value=\"\",width=10)]),\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"zlb\", \"Z lower bound:\", value=\"\",width=10)]),\n                     ui.column(2,offset=0,*[ ui.input_numeric(\"zub\", \"Z upper bound:\", value=\"\",width=10)]),\n                     ),\n                 ),\n    ui.nav_panel(\"Plot Extras\",\n                   ui.row(ui.HTML(\"<p> Additional data series for 2D and 3D plots</p>\"),\n                      ),\n                   ui.row(\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"y1var\",\"Y1 variable (2D):\",choices = ['-'], multiple=False)]),\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"y2var\",\"Y2 variable (2D):\",choices = ['-'], multiple=False)]),\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"y3var\",\"Y3 variable (2D):\",choices = ['-'], multiple=False)]),\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"z1var\",\"Z1 variable (3D):\",choices = ['-'], multiple=False)]),\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"z2var\",\"Z2 variable (3D):\",choices = ['-'], multiple=False)]),\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"z3var\",\"Z3 variable (3D):\",choices = ['-'], multiple=False)]),\n                       ),\n                    ui.row(\n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"y1mark\",\"Type:\",choices = ['dot','line'],inline = True)]),                    \n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"y2mark\",\"Type:\",choices = ['dot','line'],inline = True)]),\n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"y3mark\",\"Type:\",choices = ['dot','line'],inline = True)]),\n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"z1mark\",\"Type:\",choices = ['dot','line'],inline = True)]),\n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"z2mark\",\"Type:\",choices = ['dot','line'],inline = True)]),\n                        ui.column(2,offset=0,*[ ui.input_radio_buttons(\"z3mark\",\"Type:\",choices = ['dot','line'],inline = True)]),\n                        ),\n                   ui.row(\n                       ui.column(2,offset=0,*[ ui.input_selectize(\"y1col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ui.column(2,offset=0,*[ ui.input_selectize(\"y2col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ui.column(2,offset=0,*[ ui.input_selectize(\"y3col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ui.column(2,offset=0,*[ ui.input_selectize(\"z1col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ui.column(2,offset=0,*[ ui.input_selectize(\"z2col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ui.column(2,offset=0,*[ ui.input_selectize(\"z3col\",\"Color:\",choices = basecolors0, multiple = False)]),                    \n                       ),\n                   ui.row(\n                       ui.column(2,offset=0,*[ ui.input_numeric(\"siglev\", \"Significance Level:\", value=\"0.05\",width=20)]),\n                       ),\n                   ),\n    ui.nav_panel(\"Linear Models\",\n                 ui.row(\n                     ui.column(3, offset = 0, *[ui.input_selectize(\"depvar\",\"Dependent variable:\",choices = ['-'],multiple = False)]),\n                     ui.column(5, offset = 0, *[ui.input_selectize(\"indvar\",\"Independent Variables:\", choices = ['-'],multiple = True)]),\n                     ui.column(4, offset = 0, *[ui.input_selectize(\"tofactor\",\"Convert Numeric Variables to factors:\", choices = ['-'],multiple = True)]),\n                     ),\n                 ui.row(ui.HTML(\"<p> Use Wilkinson/Patsy notation to specify variable transformations.</p>\")\n                     ),\n                 ui.row(\n                     ui.column(9, offset = 0, *[ui.input_text('stringM','Model String:',width = '1000px')]),\n                     ui.column(3, offset = 0, *[ui.input_action_button('modelGo',\"Run Model\")]),\n                     ),\n                 ui.row(\n                     ui.output_ui(\"dloads\"),\n                     ),\n                 ui.row(\n                     ui.output_text_verbatim(\"modelSummary\")\n                     ),\n                 ),\n    ui.nav_panel(\"Linear Models: Standard Plots\",\n                  ui.row(\n                      ui.column(6,offset=0,*[ui.input_radio_buttons(\"regplotR\",\"Plot: \",choices = ['ROC', 'Leverage','Partial Regression','Influence','Fit'],inline = True)]),\n                      ui.column(6,offset=0,*[ui.input_select(\"lmsp\",\"Fit: Ind. Var:\",choices = ['-'])]),\n                      ),\n                  ui.row(\n                      ui.output_plot(\"regplot1\", width = \"900px\", height = \"600px\")\n                      ),\n                  # ui.row(\n                  #     ui.output_plot(\"regplot3\", width = \"900px\", height = \"600px\")\n                  #     ),\n                  ),\n    ui.nav_panel(\"Log\",\n                  ui.input_action_button(\"logGo\",\"Show Log\"),\n                  ui.download_button(\"logdown\",\"Download Log\"),\n                  ui.output_text_verbatim(\"logout\")\n                  ),\n    ui.nav_spacer(),\n    ui.nav_menu(\"Exit\",\n                 ui.nav_control(\n                     ui.column(1,offset=0,*[ui.input_action_button(\"exit\",\"Exit\")]),\n                     ),\n                 ),\n    \n               \nunderline = True, title = \"plotIt v.0.0.2 \")\n\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    mdl_type = reactive.value(\"OLS\") #currently supported types: OLS, LOGIT\n    mdl = reactive.value(None)\n    mdl_depvar = reactive.value('-')\n    mdl_indvar = reactive.value(())\n    mdl_stringM = reactive.value(\" - ~ \")\n    mdl_data = reactive.value(pd.DataFrame())\n    subdict = reactive.value({})\n    logstr = reactive.value(\"\")\n    dbgstr = reactive.value(f\"At server start: Figures: {plt.get_fignums()} \\n\")\n    plt_msgstr = reactive.value(\"\")\n    io_msgstr = reactive.value(\"\")\n    lm_msgstr = reactive.value(\"\")\n    plt_data = reactive.value(pd.DataFrame())\n    logstr = reactive.value(f\"Log Start: {datetime.now()}\")\n   \n    @reactive.effect\n    @reactive.event(input.exit)\n    async def do_exit():\n        #plt.close(fig)\n        await session.app.stop()\n        os.kill(os.getpid(), signal.SIGTERM)\n        max_factor_values = 50\n\n#        basecolorsalpha = ['red',  'blue', 'green', 'goldenrod', 'violet','cyan', 'yellow','grey','gold','magenta','silver','orange','olive','khaki','thistle']\n#        basecolors = [matplotlib.colors.to_rgba(item,alpha = None) for item in basecolorsalpha]\n\n        #fig = plt.figure(figsize = (10,8),tight_layout=True)\n        \n##########################################################################\n####  Log panel\n##########################################################################\n    @render.text  \n    @reactive.event(input.logGo)\n    def logout():\n        return logstr() \n\n    def pushlog(newlogstr):\n        with reactive.isolate():\n            logstr.set(logstr() + '\\n'+ newlogstr)\n        return\n\n    @render.download(filename = \"Logfile.txt\")\n    def logdown():\n        loglst = logstr().splitlines()\n        dflog = pd.DataFrame(loglst)\n        yield dflog.to_csv(index = False)\n\n        \n##########################################################################\n####  Input panel\n##########################################################################\n\n    @reactive.calc\n    def parsed_file():\n        if input.file1() is None:\n            return pd.DataFrame()\n        else: \n            fpath = str(input.file1()[0]['datapath'])\n            if (fpath[-4:] == '.csv') or (fpath[-4:] == '.CSV'):\n                df = pd.read_csv(input.file1()[0][\"datapath\"])\n            else:\n                df = pd.read_stata(input.file1()[0][\"datapath\"])\n            pushlog(\"************************************************\")\n            pushlog(\"File read: \"  + input.file1()[0]['name'])\n            pushlog(\"************************************************\")\n            stemp = df.isna().sum().sum()\n            df.replace('',np.nan,inplace = True)\n            stemp = df.isna().sum().sum() - stemp\n            \n            nona = sum(df.isna().sum(axis=1) >0)\n            \n            if (stemp > 0) | (nona > 0):\n                io_msgstr.set(f\" {stemp} blank entries converted to NaNs. {nona} rows out of {len(df)} have missing data.\")\n                pushlog(f\" {stemp} blank entries converted to NaNs. {nona} rows out of {len(df)} have missing data.\")\n                \n            #get rid of spaces in column names\n            df.columns = df.columns.str.lstrip()\n            df.columns = df.columns.str.rstrip()\n            df.columns = df.columns.str.replace(' ','_')\n            #change names to avoid collisions with protected names\n            df.columns = [collisionAvoidance(item,protected_names) for item in df.columns]\n            if (input.killna() == 'Yes') : \n                pushlog(\"Rows with missing values dropped on input by user request.\")\n                df.dropna(inplace = True)\n            plt_data.set(df)\n            return df\n\n    @render.text\n    def info():\n        df = parsed_file()\n        #df = plt_data()\n        if df.empty:\n           return \n        #display df.info\n        buffer = io.StringIO()\n        df.info(buf=buffer)\n        s = buffer.getvalue()\n        return s\n    \n    @render.table\n    def summary():\n        df = parsed_file()\n        #df = plt_data()\n        if df.empty:\n            return pd.DataFrame()\n        elif len(df) > 500000:\n            return pd.DataFrame({'': ['Too many rows','Use \\\"summary() \\\" from command line.']},index = ['Problem: ','Solution: '])\n\n        description = df.describe(include= \"all\")\n        dindex = description.index.values\n        description.insert(0,\" \",dindex)\n        return description\n\n    #warnings for data input panel ++ this doesn't seem to work\n    @render.text\n    #@reactive.event(input.updateB)\n    def io_mess():\n        return io_msgstr()  \n    \n##########################################################################\n####  Correlations panel\n##########################################################################\n    \n    @render.plot\n    @reactive.event(input.corrV)\n    def dataPD():\n        if input.corrV() == (): return\n        df = plt_data()\n        fig = plt.figure(figsize = (9,9))\n        showC = input.corrV()\n        showC = [item for item in showC]\n        dfc = df[showC].copy()\n        dfc.dropna(inplace = True)\n        nobs = len(dfc)\n        ax = sb.PairGrid(dfc, vars = showC, corner = True).set(title = f\"# Obs.= {nobs}\")\n        ax.map_diag(sb.histplot, kde=True)\n        ax.map_lower(plt.scatter, s= 2)\n        ax.map_lower(doCorr)\n        return \n\n##########################################################################\n####  Plotting panel\n##########################################################################\n\n    @reactive.effect\n    @reactive.event(input.datachoose)\n    def data_update():\n        with reactive.isolate():\n            if (input.datachoose() == 'Model Data') :\n                plt_data.set(mdl_data())\n            if (input.datachoose() == 'Input Data'):\n                plt_data.set(parsed_file())\n\n\n    @reactive.effect\n    def setupPlot():\n#        print(\"....In setupPlot\")\n        pushlog(\"Initializing Plotting Data (setupPlot)\")\n        df = pd.DataFrame()\n        df = plt_data()\n        nrow = len(df)\n        if (nrow == 0): \n#            print(f\"setupPlot...{nrow} rows in current data datachoose = {input.datachoose()}\")\n            return\n        cols = list(df.columns)\n        num_var = list(df.select_dtypes(include=np.number).columns)\n\n        str_var = [item for item in cols if item not in num_var]    \n\n        #fct used for subsetting (fct short for factor) and coloring\n\n        fct_var = [item for item in cols if ((item not in num_var) or (len(list(df[item].unique()))<=max_factor_values))]\n        #subset dictionary\n        newdict = {}                \n        newdict = {item: list(map(str,list(df[item].unique()))) for item in fct_var}\n        subdict.set(newdict)\n\n        num_fct = [item for item in list(df.columns) if (item in num_var) and len(list(df[item].unique())) <= max_factor_values]\n        ui.update_selectize(\"xvar\",choices = ['-']+num_var)\n        ui.update_selectize(\"yvar\",choices = ['-']+num_var)\n        ui.update_selectize(\"zvar\",choices = ['-']+num_var)\n        ui.update_selectize(\"cvar\",choices = ['-']+fct_var)\n        ui.update_selectize(\"fvar\",choices = ['-']+fct_var)\n        ui.update_selectize(\"corrV\", choices = num_var, selected = None)\n        ui.update_selectize(\"indvar\",choices = num_var + str_var)\n        ui.update_selectize(\"depvar\",choices =  ['-'] + num_var)\n        ui.update_selectize(\"tofactor\",choices =  num_fct) \n        ui.update_selectize(\"y1var\",choices = ['-'] + num_var)        \n        ui.update_selectize(\"y2var\",choices = ['-'] + num_var)        \n        ui.update_selectize(\"y3var\",choices = ['-'] + num_var)        \n        ui.update_selectize(\"z1var\",choices = ['-'] + num_var)        \n        ui.update_selectize(\"z2var\",choices = ['-'] + num_var)        \n        ui.update_selectize(\"z3var\",choices = ['-'] + num_var)        \n        return\n    \n    #event observer to update subsetting dictionary\n    @reactive.effect\n    @reactive.event(input.fvar)\n    def newfilter():\n        df = plt_data()\n        if len(df) == 0: return\n        #if fvar is not set, restore all rows\n        if (input.fvar() == '-'): \n            pushlog(\"Resetting row filter, all rows active.\")\n            #fct used for subsetting (fct short for factor)\n            cols = list(df.columns)\n            num_var = list(df.select_dtypes(include=np.number).columns)\n            fct_var = [item for item in cols if ((item not in num_var) or (len(list(df[item].unique()))<=max_factor_values))]\n            #fctc_var = [item for item in fct_var if (len(list(df[item].unique()))<=5)]#10\n            fct_var.insert(0,\"-\")\n            #fctc_var.insert(0,\"-\")\n            newdict = {}\n            newdict = {item: list(map(str,list(df[item].unique()))) for item in fct_var if item != '-'}\n\n            #for item in fct_var:\n            #    if item != '-' : newdict[item] = list(map(str,list(df[item].unique())))\n            \n            subdict.set(newdict)\n            ui.update_selectize(\"fitems\",choices = [], selected = [])\n            return\n        fv = input.fvar()\n        inc_items = list(df[fv].astype('str').unique())\n        ui.update_selectize(\"fitems\", choices = inc_items, selected = inc_items)\n\n    @reactive.effect\n    @reactive.event(input.fitems)\n    def subdict_update():\n        #update the dictionary of currently active rows keys=col names values = lists of active row values\n        fv = input.fvar()\n        if (fv == '-'): return\n        newdict = subdict()\n        newdict[fv] = list(input.fitems())\n        subdict.set(newdict)\n        pushlog(f\"Plot dictionary update:  Var = {fv}; Active values: {', '.join(newdict[fv])}\")\n        \n    @reactive.effect    \n    @reactive.event(input.xvar)\n    def do_xvar():\n        if input.xvar() == '-': \n            plt.clf()\n            return\n        df = plt_data()\n        ui.update_numeric(\"xlb\",value = min(df[input.xvar()]))\n        ui.update_numeric(\"xub\",value = max(df[input.xvar()]))\n\n    @reactive.effect    \n    @reactive.event(input.yvar)\n    def do_yvar():\n        if input.yvar() == '-': \n            plt.clf()\n            return\n        df = plt_data()\n        #ui.update_slider('sl1',label=\"Dot Size:\",min=0.25,max=10.0,value=2.0,step=0.25)\n        ui.update_numeric(\"ylb\",value = min(df[input.yvar()]))\n        ui.update_numeric(\"yub\",value = max(df[input.yvar()]))\n        \n    @reactive.effect    \n    @reactive.event(input.zvar)\n    def do_zvar():\n        if input.zvar() == '-': \n            plt.clf()\n            return\n        df = plt_data()\n        ui.update_numeric(\"zlb\",value = min(df[input.zvar()]))\n        ui.update_numeric(\"zub\",value = max(df[input.zvar()]))\n        \n    #displays log of currently active rows\n    @render.text\n    @reactive.event(input.updateB,input.fvar,input.xvar, input.yvar, input.zvar, input.cvar)\n    def log():  \n        if 1==1: #input.fvar() != '-':\n            return '\\n'.join([f'{item}: {subdict()[item]}' for item in subdict().keys()])\n        else:\n            return \"\"\n        \n    # @render.text\n    # def debug():\n    #     return(dbgstr())\n        \n    #adjust ui to reflect number of variables (x only histogram/boxplot)   x and y or x,y and z scatterplot \n    @render.ui\n    @reactive.event(input.xvar, input.yvar,input.zvar)\n    def pltopts():\n        df = plt_data()\n        mxbin = len(df)\n        if ((input.yvar() != '-') & (input.xvar() != '-') & (input.zvar() != '-')):\n            return ui.TagList(\n                              #ui.column(1,offset = 0,*[ui.input_action_button(\"updateB3\", \"Update\")]),\n                              ui.column(3,offset=0,*[ui.input_slider(\"sl1\",\"# dotsize\",min = 0, max = 40, value = 10)]),\n                              ui.column(1,offset = 0,),\n                              ui.column(4,offset=0,*[ui.input_checkbox_group(\"scttropts\",\"3D Scatter Plot Options:\",\n                                                choices=('Show Trend','CI','PI'),selected=(),inline = True)])\n                              )\n        elif ((input.yvar() != '-') & (input.xvar() != '-')):           \n            return ui.TagList(\n                              #ui.column(1,offset = 0,*[ui.input_action_button(\"updateB12\", \"Update\")]),\n                              ui.column(3,offset=0,*[ui.input_slider(\"sl1\",\"# dotsize\",min = 0, max = 40, value = 10)]),\n                              ui.column(1,offset = 0,),\n                              ui.column(2,offset=0,*[ui.input_checkbox_group(\"scttropts\",\"Scatter Plot Options:\",\n                                                                    choices=('Show Trend','CI','PI'),selected=(),inline = True)])\n                              )\n        elif(input.xvar() != '-'):\n            return ui.TagList(\n                              #ui.column(1,offset = 0,*[ui.input_action_button(\"updateB12\", \"Update\")]),\n                              ui.column(3,offset=0,*[ui.input_radio_buttons(\"rb1\",\"Plot type:\",choices = ['Histogram','Boxplot','Kernel Density'],selected = 'Histogram',inline=True)]),\n                              ui.column(2,offset=0,*[ui.input_numeric(\"sl1\",\"# Bins\",value=min(max(round(mxbin**0.33,0),10),50), width=2)])\n                              )\n        else:\n            return None\n   \n    @render.ui\n    @reactive.event(input.updateB, input.zvar)\n    def grphopts():\n        if(input.zvar()!= '-') :\n            return ui.TagList(ui.column(12,offset=0,*[output_widget(\"plot3\")])\n                              )\n        else:\n            return ui.TagList(ui.column(12,offset=0,*[ui.output_plot(\"Plots\", width = '900px', height = '600px')])\n                              )  \n        \n    @output\n    @render_widget\n    @reactive.event(input.updateB)\n    def plot3():\n        plt.clf()\n        if (input.xvar() == '-') | (input.yvar() == '-') | (input.zvar() == '-'): return\n        df = plt_data()\n        if len(df) == 0: \n            plt_msgstr.set(\"You need a data set before you can plot.\")\n            return\n        xv = input.xvar()\n        yv = input.yvar()\n        zv = input.zvar()\n        z1v = input.z1var()\n        z2v = input.z2var()\n        z3v = input.z3var()\n        totrow = len(df)\n        cv = input.cvar()\n        pushlog(f\"Plotting: x = {xv}, y={yv}, z={zv}, color = {cv} \")\n        if cv == '-': cv = None \n         #take out the rows that the user has decided to ignore\n        for item in list(subdict().keys()):\n            df = df[df[item].astype('str').isin(list(subdict()[item]))]\n        nrow0 = len(df)\n        dfg = df.dropna(subset = [xv, yv, zv]) #get rid fo rows with na's in the columns to be plotted\n        nrow = len(dfg)\n        #plotly can only plot up to about 400,000 to 450,000 rows of data, randomly downsample if needed.  Warn user in the title & log\n        if nrow > 400000:\n            dfg = dfg.sample(400000)\n            nrow = len(dfg)\n            ttlstr = f\"File: {input.file1()[0]['name']} <br> down-sampled!  {nrow} rows plotted out of {totrow} \"\n            pushlog(\"Plotly 3D plotting limit warning! Attempted to plot {nrow} rows, downsampled to 400,000 rows.\")\n        else:\n            ttlstr = f\"File: {input.file1()[0]['name']}:  {nrow} rows plotted out of {totrow} \"\n            pushlog(f\"{totrow-nrow0} rows filtered out, {nrow0-nrow} rows removed due to missing data.\")\n        if input.titleplt() != \"-\" :\n            ttlstr = input.titleplt()\n        if (cv != None):\n            nucolor ,nupatches, colorD = getcolor(list(dfg[cv].astype('str'))) #fix tup color map\n            colormap = {str(item) : f\"rgb({int(250*float(colorD[item][0]))},{int(250*float(colorD[item][1]))},{int(250*float(colorD[item][2]))})\" for item in colorD.keys() }\n            fig = pltx.scatter_3d(dfg,x=xv, y= yv, z = zv, color = list(dfg[cv].astype('str')), color_discrete_map = colormap, width = 900, height = 600, title = ttlstr)\n        else:\n            fig = pltx.scatter_3d(dfg,x=xv, y= yv, z = zv, width = 900, height = 900, title = ttlstr)\n        fig.update_traces(marker = dict(size = int(input.sl1()/5 +1))) # fix up dot size\n        #print(f\".....Just before Show Trend in plot3 indvar = {list(mdl_indvar())}, model: {input.stringM()}, input.indvar = {input.indvar()}\")\n        if  \"Show Trend\" in input.scttropts(): \n            res = None\n            MTYPE = None\n            #if the x, y and z variables perfectly match the variables in the most recently estimated model, then use that model's results \n            #otherwise fit a new model\n            if ((input.datachoose() == \"Model Data\") & (len(mdl_indvar())==2) & (xv in mdl_indvar()) & (yv in mdl_indvar()) \n                & (zv == mdl_depvar()) & (mdl() !=  None)):\n                pushlog(f\"in plot 3d using extant model....string={mdl_stringM()} indvar={mdl_indvar()} depvar = {mdl_indvar()}\")\n                res = mdl()\n                MTYPE = mdl_type()\n            else:# otherwise fit z against x and y from scratch\n                pushlog(f\"in plot 3d fitting response surface model....string={mdl_stringM()} ndvar={mdl_indvar()} devar = {mdl_depvar()}\")\n                if (set([0,1]) == set(df[zv])):\n                    try:\n                        res = smf.logit(f\"{zv} ~ {xv} + {yv}\" ,data= dfg).fit()\n                        MTYPE = 'LOGIT'\n                    except:\n                        res = None\n                else:\n                    try:\n                        res = smf.ols(f\"{zv} ~ {xv} + {yv}\" ,data= dfg).fit()\n                        MTYPE = 'OLS'\n                    except:\n                        res = None\n            sq = 0.05               \n            deltax = dfg[xv].max() - dfg[xv].min()\n            deltay = dfg[yv].max() - dfg[yv].min()\n            xlo = dfg[xv].min() - sq*deltax\n            xup = dfg[xv].max() + sq*deltax\n            ylo = dfg[yv].min() - sq*deltay\n            yup = dfg[yv].max() + sq*deltay\n            gridcount = 25                          \n            # create data for the response surface \n            if (res != None):             \n                xvars, yvars = np.meshgrid(np.arange(xlo,xup,deltax/gridcount),\n                                 np.arange(ylo, yup,deltay/gridcount))                \n                exog0 = pd.DataFrame({xv: xvars.ravel(), yv: yvars.ravel()}) \n                #calculate values of the dependent variable (z) for the response surface \n                res_predictions = res.get_prediction(exog=exog0,transform = True)\n                res_frame = res_predictions.summary_frame(alpha = input.siglev())\n                if MTYPE == 'LOGIT':\n                    znew   = res_frame['predicted'].values.reshape(xvars.shape)\n                    Ci_lb1 =  res_frame['ci_lower'].values.reshape(xvars.shape)\n                    Ci_ub1 =  res_frame['ci_upper'].values.reshape(xvars.shape)\n                elif MTYPE == 'OLS':\n                    znew = res_frame['mean'].values.reshape(xvars.shape)    \n                    Ci_lb1 =  res_frame['mean_ci_lower'].values.reshape(xvars.shape)\n                    Ci_ub1 =  res_frame['mean_ci_upper'].values.reshape(xvars.shape)\n                    Pi_lb1 =  res_frame['obs_ci_lower'].values.reshape(xvars.shape)\n                    Pi_ub1 =  res_frame['obs_ci_upper'].values.reshape(xvars.shape)\n            \n                #we are ready to add the traces\n                fig.add_trace(go.Surface(x=xvars,y=yvars,z=znew, opacity = 0.75,showscale = False)) #dict(orientation = 'h')))\n                if ('CI' in input.scttropts()):\n                    fig.add_trace(go.Surface(x=xvars,y=yvars,z=Ci_lb1, opacity = 0.75,showscale = False)) #dict(orientation = 'h')))\n                    fig.add_trace(go.Surface(x=xvars,y=yvars,z=Ci_ub1, opacity = 0.75,showscale = False)) #dict(orientation = 'h')))\n                if ('PI' in input.scttropts()) & (MTYPE == 'OLS'):\n                    fig.add_trace(go.Surface(x=xvars,y=yvars,z=Pi_lb1, opacity = 0.75,showscale = False)) #dict(orientation = 'h')))\n                    fig.add_trace(go.Surface(x=xvars,y=yvars,z=Pi_ub1, opacity = 0.75,showscale = False)) #dict(orientation = 'h')))\n                #fig.update_traces(colorbar = dict(orientation='h', y = -0.25, x = 0.5))\n        if (z1v != '-'):\n            dfg = dfg.dropna(subset = [z1v]) #get rid fo rows with na's in the columns to be plotted\n            if (input.z1mark() == 'dot'):\n                fig.add_trace(go.Scatter3d(x = dfg[xv], y = dfg[yv], z = dfg[z1v],marker = dict(size = int(input.sl1()/5 +1))))\n                pushlog(f\" 3D extra plot #1 variable= {input.z1var()} color = {input.z1col()} NOTE: missing values are dropped.\")\n            elif (input.z1mark() == 'line'):\n                pushlog(f\" 3D extra plot #1  variable= {input.z1var()} color = {input.z1col()} NOTE: missing values are dropped.\")\n                fig.add_trace(go.Mesh3d( x = dfg[xv], y = dfg[yv], z = dfg[z1v]))\n        if (z2v != '-'):\n            dfg = dfg.dropna(subset = [z2v]) #get rid fo rows with na's in the columns to be plotted\n            if (input.z2mark() == 'dot'):\n                fig.add_trace(go.Scatter3d(x = dfg[xv], y = dfg[yv], z = dfg[z2v],marker = dict(size = int(input.sl1()/5 +1))))\n                pushlog(f\" 3D extra plot #2 variable= {input.z2var()} color = {input.z2col()} NOTE: missing values are dropped.\")\n            elif (input.z2mark() == 'line'):\n                pushlog(f\" 3D extra plot #2  variable= {input.z2var()} color = {input.z2col()} NOTE: missing values are dropped.\")\n                fig.add_trace(go.Mesh3d( x = dfg[xv], y = dfg[yv], z = dfg[z2v]))\n        if (z3v != '-'):\n            dfg = dfg.dropna(subset = [z3v]) #get rid fo rows with na's in the columns to be plotted\n            if (input.z3mark() == 'dot'):\n                fig.add_trace(go.Scatter3d(x = dfg[xv], y = dfg[yv], z = dfg[z3v],marker = dict(size = int(input.sl1()/5 +1))))\n                pushlog(f\" 3D extra plot #2 variable= {input.z3var()} color = {input.z3col()} NOTE: missing values are dropped.\")\n            elif (input.z3mark() == 'line'):\n                pushlog(f\" 3D extra plot #2  variable= {input.z3var()} color = {input.z3col()} NOTE: missing values are dropped.\")\n                fig.add_trace(go.Mesh3d( x = dfg[xv], y = dfg[yv], z = dfg[z3v]))\n        return fig\n                \n    @render.plot\n    @reactive.event(input.updateB)\n    def Plots():\n        if (input.zvar() != '-') : return # plotting happening in plot3()\n        if (input.xvar() == '-'):\n            plt.clf()\n            return\n        plt.clf()\n        df = plt_data()\n        if len(df) == 0: \n            plt_msgstr.set(\"You need a data set before you can plot.\")\n            return\n        xv = input.xvar()\n        yv = input.yvar()\n        zv = input.zvar()\n        totrow = len(df)\n        cv = input.cvar()\n        pushlog(f\"plotting x = {xv}, y = {yv}, color = {cv}\")\n        #print(f\"Beginning of plots ...Model: {mdl_stringM()} indvar = {mdl_indvar()}  depvar = {mdl_depvar()}\")\n\n\n        #expand the plot axes a squidge for esthetics\n        squidgeVal = 0.05\n        if (xv != '-'):\n            squidgeX = (input.xub()-input.xlb())*squidgeVal\n        if (yv != '-'):\n            squidgeY = (input.yub()-input.ylb())*squidgeVal\n#        if (zv != '-'):\n#            squidgeZ = (input.zub()-input.zlb())*squidgeVal\n     \n        \n        #create the row subset for plotting\n      \n        for item in list(subdict().keys()):\n           df = df[df[item].astype('str').isin(list(subdict()[item]))]\n        nrow1 = len(df)\n        pushlog(f\"{totrow-nrow1} rows excluded via filter.\")\n        \n        #drop rows that have NaN values in the columns to be plotted\n        sbst = [xv]\n        if yv != '-': sbst.append(yv)\n        if zv != '-': sbst.append(zv)\n        dfg = df.dropna(subset = sbst)\n        nrow = len(dfg)\n        pushlog(f\"{nrow1 - nrow} rows dropped from plotting set due to missing data.\")\n        \n        if (cv != '-'):\n            colorlist,lpatches,colorD = getcolor(list(dfg[cv].astype('str')))\n            color_data = dfg[cv].astype('str')\n        else:\n            cv = None\n            colorlist = None\n            color_data = None\n            \n        fig = plt.figure(2,figsize = (12,9), tight_layout = False)\n        fig.clf()\n        #make this a user choice later\n        sb.set_style(\"darkgrid\", {\"grid.color\": \".6\", \"grid.linestyle\": \":\"})\n\n        #initialize some parameters\n        edgecol = 'black'\n        kdeflag = False\n        titlestr = f'File: {input.file1()[0][\"name\"]} rows shown {nrow} out of {totrow}'        \n        if  ((xv != '-') & (yv != '-')):\n            #numx = dfg[xv].unique\n            ax=sb.scatterplot(data = dfg,x = xv,y = yv, c = colorlist,  s = input.sl1())\n            #print(f\".....Just before Show Trend in plots mdl_indvar = {list(mdl_indvar())}, model: {mdl_stringM()}, input.indvar = {list(input.indvar())}, input.depvar = {input.depvar()}\")\n            if \"Show Trend\" in input.scttropts():\n                res = None\n                if ((input.datachoose() == \"Model Data\") & (len(mdl_indvar())==1) & (xv in mdl_indvar()) & (yv in mdl_depvar()) \n                       & (mdl() !=  None)):\n                    pushlog(f\"...in plots using extant model....string={mdl_stringM()} imdl_ndvar={mdl_indvar()} mdl_depvar= {mdl_depvar()} mdl good? {mdl() != None}\")\n                    res = mdl()\n                    MTYPE = mdl_type()\n                else:\n                    if (set([0,1]) == set(df[yv])):\n                        try:\n                            res = smf.logit(f\"{yv} ~ {xv}\" ,data= dfg).fit()\n                            MTYPE = 'LOGIT'\n                        except:\n                            res = None\n                    else:\n                        try:\n                            pushlog(f\"...in plots using new model....string={mdl_stringM()} imdl_ndvar={mdl_indvar()} mdl_depvar= {mdl_depvar()} mdl good? {mdl() != None}\")\n                            res = smf.ols(f\"{yv} ~ {xv}\" ,data= dfg).fit() #normal operations fit a new model put try/catch here\n                            MTYPE = 'OLS'\n                        except:\n                            res = None\n                   \n                sq = 0.05\n                deltax = dfg[xv].max() - dfg[xv].min() \n                xlo = dfg[xv].min() - sq*deltax\n                xup = dfg[xv].max() + sq*deltax\n                gridcount = 25   \n                xvar = np.arange(xlo, xup, deltax/gridcount)                       \n                newdat = pd.DataFrame({xv : xvar})\n                if res != None:\n                    GOTREND = True\n                    #yvar = res.predict(mdl_stringM(),data = newdat)\n                    try:\n                        res_predictions = res.get_prediction(exog=newdat,transform = True)\n                        res_frame = res_predictions.summary_frame(alpha = input.siglev())\n                    except:\n                        pushlog(\"Predictions failed!\")\n                        pushlog(\" Prediction data: \")\n                        pushlog(f\"{newdat.head()}\")\n                        GOTREND = False\n                    if (GOTREND):\n                        if MTYPE == 'LOGIT':\n                            ynew   =  res_frame['predicted'].values.reshape(xvar.shape)\n                            Ci_lb1 =  res_frame['ci_lower'].values.reshape(xvar.shape)\n                            Ci_ub1 =  res_frame['ci_upper'].values.reshape(xvar.shape)\n                            Pi_ub1 = []\n                            Pi_lb1 = []\n                        elif MTYPE == 'OLS':\n                            ynew = res_frame['mean'].values.reshape(xvar.shape)    \n                            Ci_lb1 =  res_frame['mean_ci_lower'].values.reshape(xvar.shape)\n                            Ci_ub1 =  res_frame['mean_ci_upper'].values.reshape(xvar.shape)\n                            Pi_lb1 =  res_frame['obs_ci_lower'].values.reshape(xvar.shape)\n                            Pi_ub1 =  res_frame['obs_ci_upper'].values.reshape(xvar.shape)\n                        ax = sb.lineplot(x=xvar, y= ynew, color = 'red') \n                        if ('CI' in input.scttropts()):\n                            ax = sb.lineplot(x = xvar, y= Ci_lb1, color = 'green')\n                            ax = sb.lineplot(x = xvar, y= Ci_ub1, color = 'green')\n                        if (len(Pi_ub1) != 0) & ('PI' in input.scttropts()):\n                            ax = sb.lineplot(x = xvar, y= Pi_lb1, color = 'goldenrod')\n                            ax = sb.lineplot(x = xvar, y= Pi_ub1, color = 'goldenrod')                            \n            # plot extra series if needed                    \n            if (input.y1var() != '-'):\n                if (input.y1mark() == 'dot'):\n                    ax=sb.scatterplot(data = dfg,x = xv,y = input.y1var(), c = input.y1col(),  s = input.sl1())\n                    pushlog(f\" extra plot #1 variable= {input.y1var()} color = {input.y1col()} NOTE: missing values are dropped.\")\n                    #ax.add(sb.Dot())    \n                elif (input.y1mark() == 'line'):\n                    pushlog(f\" extra plot #1  variable= {input.y1var()} color = {input.y1col()} NOTE: missing values are dropped.\")\n                    ax = sb.lineplot(data= dfg, x=xv, y=input.y1var(), color = input.y1col())\n                    plt.legend(title = input.y1var(), loc = 1, fontsize = 12)\n            if (input.y2var() != '-'):\n                if (input.y2mark() == 'dot'):\n                    ax=sb.scatterplot(data = dfg,x = xv,y = input.y2var(), c = input.y2col(),  s = input.sl1())\n                    pushlog(f\" extra plot #2 variable= {input.y2var()} color = {input.y2col()} NOTE: missing values are dropped.\")  \n                elif (input.y2mark() == 'line'):\n                    pushlog(f\" extra plot #2 variable= {input.y2var()} color = {input.y2col()} NOTE: missing values are dropped.\")\n                    ax = sb.lineplot(data= dfg, x=xv, y=input.y2var(), color = input.y2col())\n                    plt.legend(title = input.y2var(), loc = 1, fontsize = 12)\n            if (input.y3var() != '-'):\n                if (input.y3mark() == 'dot'):\n                    ax=sb.scatterplot(data = dfg,x = xv,y = input.y3var(), c = input.y3col(),  s = input.sl1())\n                    pushlog(f\" extra plot #2 variable= {input.y23ar()} color = {input.y3col()} NOTE: missing values are dropped.\")  \n                elif (input.y3mark() == 'line'):\n                    pushlog(f\" extra plot #2 variable= {input.y3var()} color = {input.y3col()} NOTE: missing values are dropped.\")\n                    ax = sb.lineplot(data= dfg, x=xv, y=input.y3var(), color = input.y3col())\n                    plt.legend(title = input.y3var(), loc = 1, fontsize = 12)\n                    \n            ax.set_title(titlestr)\n            ax.set_xlabel(xv)\n            ax.set_ylabel(yv)\n            ax.set_xlim(input.xlb()-squidgeX,input.xub()+squidgeX)\n            ax.set_ylim(input.ylb()-squidgeY,input.yub()+squidgeY)\n            if (cv != None) :\n                ax.legend(title = cv, handles = lpatches)\n\n        elif (xv != '-'):\n            if (input.rb1() == 'Boxplot'):\n                ax =sb.boxplot(data = dfg, y=xv,x=color_data, notch = True)\n                #ax =sb.boxplot(data = dfg, y=xv,x=colorlist, notch = True)\n                ax.set_title(titlestr)\n            else: \n               if (input.rb1() == \"Kernel Density\"):\n                   kdeflag = True\n               if (cv != None):\n                   edgecol = None\n               else: edgecol = 'black'\n               ax = sb.histplot(data = dfg, x=xv, hue = color_data, ec = edgecol ,kde = kdeflag,bins=input.sl1())\n               #ax = sb.histplot(data = dfg, x=xv, color = colorlist, ec = edgecol,kde = kdeflag,bins=input.sl1())\n               ax.set_title(titlestr)\n\n               #ax.set_title(f'File: {input.file1()[0][\"name\"]} #rows = {nrow}')\n               ax.set_xlabel(xv)\n               ax.set_xlim(input.xlb()-squidgeX,input.xub()+squidgeX)\n        else: \n            return\n        return plt.draw()\n\n    @render.download(filename=\"plotIt_Plotting_data.csv\")\n    def downloadDP():\n        df = plt_data()\n        #create the row subset for graphing    \n        for item in list(subdict().keys()):\n            df = df[df[item].astype('str').isin(list(subdict()[item]))]\n        yield df.to_csv(index = False)\n\n    #warnings for plotting panel\n    @render.text\n    @reactive.event(input.updateB)\n    def plt_mess():\n        return plt_msgstr()  \n        \n##########################################################################\n####  Linear Models panel\n##########################################################################\n                        \n    @reactive.effect\n    @reactive.event(input.depvar)    \n    def do_depvar():\n        df = plt_data()\n        #print(\".....resetting model in do_depvar\")\n        #mdl.set(None)\n        if len(df) == 0: return\n        num_var = list(df.select_dtypes(include=np.number).columns)\n        str_var = list(df.select_dtypes(exclude=np.number).columns)\n        if (input.depvar() == '-'): \n            ui.update_selectize('depvar',choices = ['-'] + num_var)\n            ui.update_selectize('indvar',choices = num_var + str_var)\n        else: \n            indvar_choices = [item for item in num_var+str_var if item != input.depvar()]\n            ui.update_selectize('indvar',choices = indvar_choices)\n        return\n                        \n    @reactive.effect\n    @reactive.event(input.indvar,input.depvar)\n    def doMstring():\n        ui.update_text(\"stringM\",value = f\"{''.join(input.depvar())} ~ {' + '.join(input.indvar())}\")\n        return\n            \n    @reactive.effect\n    @reactive.event(input.modelGo)\n    def runModel():\n        df = plt_data()\n        #print(f\"At runModel Top.::::::  input.indvar = {input.indvar()}\")\n        size0 = len(df)\n        if (input.depvar() == '-'): \n            return\n        #apply the current subset items are column names items are the dictionary keys, \n        #   the dictionary entry is the list of active row values for that column.\n        for item in list(subdict().keys()):\n            df = df[df[item].astype('str').isin(list(subdict()[item]))]\n        size1 = len(df)\n        #create factors for numerical variables as set by user by changing them into strings\n        if len(input.tofactor()) >0 :\n            pushlog(f\"runModel: Creating factors for: {', '.join(input.tofactor())}\")\n        for item in input.tofactor():\n            df[item] = df[item].astype('str')\n            \n        #manually remove rows containing NaNs in the dependent or independent variables columns\n        df.dropna(subset = [input.depvar()] + list(input.indvar()),inplace = True)   \n        size2 = len(df)              \n        #check to see if the dependent variable is binary (use logit) has several outcomes (use ols) or just one (quit)\n        pushlog(f\"runModel: {size0-size1} rows deleted by filter, {size1-size2} rows deleted due to missing data.\")\n        outcomes = list(df[input.depvar()].unique())\n        no_outcomes = len(outcomes)\n        STOP = False\n        if (no_outcomes <= 1):\n            STOP = True\n        elif ((no_outcomes == 2) & (0 in outcomes) & (1 in outcomes)):\n            try:\n                res = smf.logit(formula = input.stringM(), data=df).fit()\n            except: \n                STOP = True\n            mdl_type.set('LOGIT')\n        else:\n            try:\n                res = smf.ols(formula=input.stringM(), data=df).fit()\n            except: \n                STOP = True            \n            mdl_type.set('OLS')\n        if STOP:\n            mdl_indvar.set([])\n            mdl.set(None)\n            ui.update_radio_buttons(\"datachoose\",choices = ['Input Data'],selected = 'Input Data')\n            pushlog(f\"{mdl_type()} estimation failed. Model = {input.stringM()} \")\n            return\n        # regression succeeded          \n        mdl.set(res) \n        mdl_d = pd.concat([res.model.data.orig_exog,res.model.data.orig_endog],axis = 1)\n        \n        if (mdl_type() == 'LOGIT') :\n            mdl_d['Deviance_Resid'] = res.resid_dev\n            mdl_d['Predictions'] = res.predict()\n        elif (mdl_type()=='OLS'):\n            prediction_res = res.get_prediction(transform  = True)\n            res_frame= prediction_res.summary_frame(alpha = input.siglev())\n            mdl_d['CI_lb'] =  res_frame['mean_ci_lower']\n            mdl_d['CI_ub'] =  res_frame['mean_ci_upper']\n            mdl_d['PI_lb'] =  res_frame['obs_ci_lower']\n            mdl_d['PI_ub'] =  res_frame['obs_ci_upper']\n            mdl_d['Predictions'] = res_frame['mean']\n            mdl_d['Residuals'] =  res.resid\n        addoncols = [item for item in df.columns if item not in mdl_d.columns]\n        mdl_d = pd.concat([mdl_d,df[addoncols]],axis = 1)\n        mdl_data.set(mdl_d)\n        mdl_indvar.set(input.indvar())\n        mdl_depvar.set(input.depvar())\n        mdl_stringM.set(input.stringM())\n        #now setup the plotting variables\n        ui.update_select(\"lmsp\",choices = ['-'] + list(res.params.index),selected = None)\n        if (mdl_type() == 'LOGIT'):\n            ui.update_radio_buttons(\"regplotR\",choices = ['ROC', 'Partial Regression'], selected = 'ROC')\n        else:\n            ui.update_radio_buttons(\"regplotR\",choices = ['Leverage','Partial Regression','Influence','Fit'],selected = 'Leverage')\n        ui.update_radio_buttons(\"datachoose\",choices = ['Input Data', 'Model Data'],selected = 'Input Data')\n        pushlog(f\"Estimation successful. {mdl_type()} ...Model: {mdl_stringM()}\")\n        pushlog(str( mdl().summary()))\n        return\n    \n    @render.text\n    @reactive.event(input.modelGo)\n    def modelSummary():\n        if (mdl() == None) : return f\"Model estimation failed.  Check data and model. {input.stringM()}\"\n        return \"Model: \" + input.stringM() + \"\\n\\n\" + str( mdl().summary())\n        \n    @render.ui\n    @reactive.event(input.modelGo)\n    def dloads():\n        if (mdl() != None):\n            return ui.TagList(\n               ui.column(3,offset = 0,*[ui.download_button(\"downloadD\", \"Download Data Set\")]),\n               )\n        else:\n            return None\n              \n    @render.download(filename=\"plotIt_Model_Data.csv\")\n    def downloadD():\n        yield mdl_data().to_csv(index = False)\n         \n##########################################################################\n####  Linear Models: Standard Plots panel\n##########################################################################\n        \n    @render.plot\n    #@reactive.event(mdl)\n    def regplot1():\n        if (mdl() == None) : \n            lm_msgstr.set(\"Run a model using the Linear Model tab before plotting it (first numbers, then pictures)\")\n            return\n        lm_msgstr.set(\"\")\n        fig = plt.figure(figsize=(8, 8)) \n        if (input.regplotR() == 'Partial Regression'):\n            plot_partregress_grid(mdl(), fig=fig)\n            plt.axhline(y=0)\n            return plt.draw()\n        if (input.regplotR() == 'ROC') :\n            if (mdl_type() != 'LOGIT') : return\n            # Calculate ROC curve\n            fpr, tpr, thresholds = roc_curve(mdl_data()[input.depvar()], mdl_data()['Predictions']) \n            roc_auc = auc(fpr, tpr)\n            # Plot the ROC curve\n            ax = fig.add_subplot()\n            ax.plot(fpr, tpr)\n            ax.plot([0, 1], [0, 1], 'k--')\n            ax.set_xlim([0.0, 1.0])\n            ax.set_ylim([0.0, 1.05])\n            ax.set_xlabel('False Positive Rate')\n            ax.set_ylabel('True Positive Rate')\n            ax.set_title(f\"ROC  Model: {input.stringM()}, AUC={round(roc_auc,3)}\")\n            return plt.draw()\n        if (input.regplotR() == 'Leverage'):\n            if(mdl_type()!= 'OLS'): return\n            plot_leverage_resid2(mdl())          \n            return plt.draw()\n        if (input.regplotR() == 'Influence'):\n            if mdl_type() != 'OLS' : return\n            influence_plot(mdl(),fig = fig)          \n            return plt.draw()\n        if (input.regplotR() == 'Fit'):\n            ivs = list(mdl().params.index)\n            targetv = input.lmsp()\n            if (targetv in ivs):\n                varno = ivs.index(targetv)  \n                fig = plot_fit(mdl(),varno,vlines = False)\n            else:\n                return\n            fig.tight_layout(pad=1.0)\n            return plt.draw()\n\n    #warnings for linearmodels plot\n    @render.text\n    @reactive.event(input.updateM)\n    def lm_mess():\n            return lm_msgstr()\n        \n\n#app = App(app_ui, server,debug=True)\napp = App(app_ui, server)\n\n", "type": "text"}]